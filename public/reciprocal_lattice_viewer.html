<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crystallographic Reciprocal Lattice Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        input[type="file"], input[type="range"], input[type="number"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            height: 20px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <div class="control-group">
                <label>Load CIF File:</label>
                <div class="file-input-wrapper">
                    <input type="file" id="cifFile" accept=".cif" />
                    Choose CIF File
                </div>
            </div>
            
            <div class="control-group">
                <label>Load HKL Files (multiple allowed):</label>
                <div class="file-input-wrapper">
                    <input type="file" id="hklFile" accept=".hkl" multiple />
                    Choose HKL File(s)
                </div>
            </div>
            
            <div class="control-group">
                <label>Point Size: <span id="pointSizeValue">5</span></label>
                <input type="range" id="pointSize" min="0.1" max="10" step="0.1" value="5">
            </div>
            
            <div class="control-group">
                <label>Rotation Sensitivity: <span id="rotationSensitivityValue">1</span></label>
                <input type="range" id="rotationSensitivity" min="0.1" max="3" step="0.1" value="1">
            </div>
            
            <div class="control-group">
                <label>Color By:</label>
                <div style="margin-top: 5px;">
                    <label style="font-size: 11px; display: block; margin-bottom: 3px;">
                        <input type="radio" name="colorMode" value="multiplicity" checked style="margin-right: 5px;"> Multiplicity
                    </label>
                    <label style="font-size: 11px; display: block;">
                        <input type="radio" name="colorMode" value="file" style="margin-right: 5px;"> Source File
                    </label>
                </div>
            </div>
            
            <div class="control-group">
                <button id="resetCamera">Reset Camera</button>
                <button id="toggleAxes">Toggle Axes</button>
            </div>
            
            <div class="control-group">
                <label>Loaded Files:</label>
                <div id="fileList" style="font-size: 10px; color: #ccc; max-height: 60px; overflow-y: auto;"></div>
            </div>
        </div>
        
        <div id="info">
            <div>Camera Controls: Left click + drag to rotate, Scroll to zoom</div>
            <div id="cellParams"></div>
            <div id="reflectionCount"></div>
        </div>
        
        <div id="loading">Loading...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class ReciprocalLatticeViewer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.latticePoints = null;
                this.axes = null;
                this.unitCellParams = null;
                this.hklData = null;
                this.reciprocalMatrix = null;
                this.rotationSensitivity = 1;
                this.sceneGroup = null;
                this.currentQuaternion = new THREE.Quaternion();
                this.isRotating = false;
                this.lastMousePosition = { x: 0, y: 0 };
                this.loadedFiles = []; // Track loaded HKL files
                
                this.init();
                this.setupEventListeners();
            }
            
            init() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);
                
                // Camera setup - orthographic
                const frustumSize = 50;
                this.camera = new THREE.OrthographicCamera(
                    -frustumSize * window.innerWidth / window.innerHeight / 2,
                    frustumSize * window.innerWidth / window.innerHeight / 2,
                    frustumSize / 2,
                    -frustumSize / 2,
                    0.1, 1000
                );
                this.camera.position.set(20, 20, 20);
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                // Controls setup (TrackballControls-like behavior)
                this.setupControls();
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // Add coordinate axes
                this.createAxes();
                
                // Start render loop
                this.animate();
            }
            
            setupControls() {
                // Create a group to hold all scene objects for rotation
                this.sceneGroup = new THREE.Group();
                this.scene.add(this.sceneGroup);
                
                // Trackball rotation controls
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    if (event.button === 0) { // Left mouse button
                        this.isRotating = true;
                        this.lastMousePosition = { x: event.clientX, y: event.clientY };
                        event.preventDefault();
                    }
                });
                
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (this.isRotating) {
                        const deltaX = event.clientX - this.lastMousePosition.x;
                        const deltaY = event.clientY - this.lastMousePosition.y;
                        
                        // Create rotation quaternions
                        const rotationX = new THREE.Quaternion();
                        const rotationY = new THREE.Quaternion();
                        
                        // Rotate around Y-axis for horizontal mouse movement
                        rotationY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * 0.01 * this.rotationSensitivity);
                        
                        // Rotate around X-axis for vertical mouse movement
                        rotationX.setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * 0.01 * this.rotationSensitivity);
                        
                        // Combine rotations (order matters for avoiding gimbal lock)
                        const combinedRotation = new THREE.Quaternion();
                        combinedRotation.multiplyQuaternions(rotationY, rotationX);
                        
                        // Apply rotation to current quaternion
                        this.currentQuaternion.multiplyQuaternions(combinedRotation, this.currentQuaternion);
                        this.sceneGroup.setRotationFromQuaternion(this.currentQuaternion);
                        
                        this.lastMousePosition = { x: event.clientX, y: event.clientY };
                        event.preventDefault();
                    }
                });
                
                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.isRotating = false;
                });
                
                this.renderer.domElement.addEventListener('mouseleave', () => {
                    this.isRotating = false;
                });
                
                // Zoom with mouse wheel
                this.renderer.domElement.addEventListener('wheel', (event) => {
                    const zoomSpeed = 0.1;
                    const currentDistance = this.camera.position.length();
                    
                    if (event.deltaY > 0 && currentDistance < 200) {
                        this.camera.position.multiplyScalar(1 + zoomSpeed);
                    } else if (event.deltaY < 0 && currentDistance > 5) {
                        this.camera.position.multiplyScalar(1 - zoomSpeed);
                    }
                    
                    // Update orthographic camera frustum
                    const distance = this.camera.position.length();
                    const frustumSize = distance;
                    this.camera.left = -frustumSize * window.innerWidth / window.innerHeight / 2;
                    this.camera.right = frustumSize * window.innerWidth / window.innerHeight / 2;
                    this.camera.top = frustumSize / 2;
                    this.camera.bottom = -frustumSize / 2;
                    this.camera.updateProjectionMatrix();
                    
                    event.preventDefault();
                });
                
                // Disable context menu
                this.renderer.domElement.addEventListener('contextmenu', (event) => {
                    event.preventDefault();
                });
            }
            
            createAxes() {
                if (this.axes) {
                    if (this.sceneGroup) {
                        this.sceneGroup.remove(this.axes);
                    } else {
                        this.scene.remove(this.axes);
                    }
                }
                
                const axesGroup = new THREE.Group();
                
                if (this.aStarVec && this.bStarVec && this.cStarVec) {
                    const scale = 5; // Scale factor to make axes smaller than point cloud
                    
                    // a* vector (red)
                    const aGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        this.aStarVec.clone().multiplyScalar(scale)
                    ]);
                    const aMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
                    const aLine = new THREE.Line(aGeometry, aMaterial);
                    axesGroup.add(aLine);
                    
                    // b* vector (green)
                    const bGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        this.bStarVec.clone().multiplyScalar(scale)
                    ]);
                    const bMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
                    const bLine = new THREE.Line(bGeometry, bMaterial);
                    axesGroup.add(bLine);
                    
                    // c* vector (blue)
                    const cGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        this.cStarVec.clone().multiplyScalar(scale)
                    ]);
                    const cMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
                    const cLine = new THREE.Line(cGeometry, cMaterial);
                    axesGroup.add(cLine);
                } else {
                    // Fallback to standard XYZ axes if no reciprocal vectors available
                    const scale = 5;
                    const xGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(5 * scale, 0, 0)
                    ]);
                    const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
                    const xLine = new THREE.Line(xGeometry, xMaterial);
                    axesGroup.add(xLine);
                    
                    const yGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 5 * scale, 0)
                    ]);
                    const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 3 });
                    const yLine = new THREE.Line(yGeometry, yMaterial);
                    axesGroup.add(yLine);
                    
                    const zGeometry = new THREE.BufferGeometry().setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        new THREE.Vector3(0, 0, 5 * scale)
                    ]);
                    const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, linewidth: 3 });
                    const zLine = new THREE.Line(zGeometry, zMaterial);
                    axesGroup.add(zLine);
                }
                
                this.axes = axesGroup;
                if (this.sceneGroup) {
                    this.sceneGroup.add(this.axes);
                } else {
                    this.scene.add(this.axes);
                }
            }
            
            setupEventListeners() {
                // File input change handlers
                document.getElementById('cifFile').addEventListener('change', (event) => {
                    this.loadCifFile(event.target.files[0]);
                });
                
                document.getElementById('hklFile').addEventListener('change', (event) => {
                    const files = Array.from(event.target.files);
                    files.forEach(file => this.loadHklFile(file));
                });
                
                // Click handlers for file input wrappers
                const fileWrappers = document.querySelectorAll('.file-input-wrapper');
                fileWrappers[0].addEventListener('click', () => {
                    document.getElementById('cifFile').click();
                });
                
                fileWrappers[1].addEventListener('click', () => {
                    document.getElementById('hklFile').click();
                });
                
                document.getElementById('pointSize').addEventListener('input', (event) => {
                    document.getElementById('pointSizeValue').textContent = event.target.value;
                    this.updateVisualization();
                });
                
                document.getElementById('rotationSensitivity').addEventListener('input', (event) => {
                    this.rotationSensitivity = parseFloat(event.target.value);
                    document.getElementById('rotationSensitivityValue').textContent = event.target.value;
                });
                
                document.getElementById('resetCamera').addEventListener('click', () => {
                    this.camera.position.set(20, 20, 20);
                    this.camera.lookAt(0, 0, 0);
                    // Reset rotation
                    this.currentQuaternion.set(0, 0, 0, 1);
                    if (this.sceneGroup) {
                        this.sceneGroup.setRotationFromQuaternion(this.currentQuaternion);
                    }
                });
                
                document.getElementById('toggleAxes').addEventListener('click', () => {
                    this.axes.visible = !this.axes.visible;
                });
                
                // Color mode selection
                document.querySelectorAll('input[name="colorMode"]').forEach(radio => {
                    radio.addEventListener('change', () => {
                        this.updateVisualization();
                    });
                });
                
                window.addEventListener('resize', () => {
                    const frustumSize = 50;
                    this.camera.left = -frustumSize * window.innerWidth / window.innerHeight / 2;
                    this.camera.right = frustumSize * window.innerWidth / window.innerHeight / 2;
                    this.camera.top = frustumSize / 2;
                    this.camera.bottom = -frustumSize / 2;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            async loadCifFile(file) {
                if (!file) return;
                
                const text = await file.text();
                this.parseCifFile(text);
            }
            
            async loadHklFile(file) {
                if (!file) return;
                
                document.getElementById('loading').style.display = 'block';
                
                const text = await file.text();
                this.parseHklFile(text, file.name);
                
                document.getElementById('loading').style.display = 'none';
            }
            
            parseCifFile(text) {
                const lines = text.split('\n');
                const params = {};
                
                lines.forEach(line => {
                    line = line.trim();
                    if (line.startsWith('_cell_length_a')) {
                        params.a = parseFloat(line.split(/\s+/)[1]);
                    } else if (line.startsWith('_cell_length_b')) {
                        params.b = parseFloat(line.split(/\s+/)[1]);
                    } else if (line.startsWith('_cell_length_c')) {
                        params.c = parseFloat(line.split(/\s+/)[1]);
                    } else if (line.startsWith('_cell_angle_alpha')) {
                        params.alpha = parseFloat(line.split(/\s+/)[1]) * Math.PI / 180;
                    } else if (line.startsWith('_cell_angle_beta')) {
                        params.beta = parseFloat(line.split(/\s+/)[1]) * Math.PI / 180;
                    } else if (line.startsWith('_cell_angle_gamma')) {
                        params.gamma = parseFloat(line.split(/\s+/)[1]) * Math.PI / 180;
                    }
                });
                
                this.unitCellParams = params;
                this.calculateReciprocalMatrix();
                this.updateCellParamsDisplay();
                this.createAxes(); // Recreate axes with unit cell vectors
                this.updateVisualization();
            }
            
            parseHklFile(text, filename = 'unknown') {
                const lines = text.split('\n');
                const newData = [];
                
                lines.forEach(line => {
                    line = line.trim();
                    if (line && !line.startsWith('#')) {
                        const parts = line.split(/\s+/);
                        if (parts.length >= 4) {
                            const h = parseInt(parts[0]);
                            const k = parseInt(parts[1]);
                            const l = parseInt(parts[2]);
                            const intensity = parseFloat(parts[3]);
                            const sigma = parts.length > 4 ? parseFloat(parts[4]) : 0;
                            
                            if (!isNaN(h) && !isNaN(k) && !isNaN(l) && !isNaN(intensity)) {
                                newData.push({ h, k, l, intensity, sigma, source: filename });
                            }
                        }
                    }
                });
                
                // Append to existing data or create new
                if (this.hklData) {
                    this.hklData = this.hklData.concat(newData);
                } else {
                    this.hklData = newData;
                }
                
                // Track loaded file
                if (!this.loadedFiles.includes(filename)) {
                    this.loadedFiles.push(filename);
                }
                
                this.updateFileList();
                this.updateVisualization();
            }
            
            calculateReciprocalMatrix() {
                if (!this.unitCellParams) return;
                
                const { a, b, c, alpha, beta, gamma } = this.unitCellParams;
                
                // Calculate reciprocal cell parameters
                const V = a * b * c * Math.sqrt(1 + 2 * Math.cos(alpha) * Math.cos(beta) * Math.cos(gamma) 
                    - Math.cos(alpha)**2 - Math.cos(beta)**2 - Math.cos(gamma)**2);
                
                const astar = b * c * Math.sin(alpha) / V;
                const bstar = a * c * Math.sin(beta) / V;
                const cstar = a * b * Math.sin(gamma) / V;
                
                const alphastar = Math.acos((Math.cos(beta) * Math.cos(gamma) - Math.cos(alpha)) / (Math.sin(beta) * Math.sin(gamma)));
                const betastar = Math.acos((Math.cos(alpha) * Math.cos(gamma) - Math.cos(beta)) / (Math.sin(alpha) * Math.sin(gamma)));
                const gammastar = Math.acos((Math.cos(alpha) * Math.cos(beta) - Math.cos(gamma)) / (Math.sin(alpha) * Math.sin(beta)));
                
                // Create reciprocal space transformation matrix
                // Store the basis vectors for easy access
                const scale = 10; // Scale factor for visualization
                
                // Store individual reciprocal lattice vectors
                this.aStarVec = new THREE.Vector3(astar * scale, 0, 0);
                this.bStarVec = new THREE.Vector3(
                    bstar * Math.cos(gammastar) * scale, 
                    bstar * Math.sin(gammastar) * scale, 
                    0
                );
                this.cStarVec = new THREE.Vector3(
                    cstar * Math.cos(betastar) * scale,
                    cstar * (Math.cos(alphastar) - Math.cos(betastar) * Math.cos(gammastar)) / Math.sin(gammastar) * scale,
                    cstar * Math.sqrt(1 - Math.cos(betastar)**2 - ((Math.cos(alphastar) - Math.cos(betastar) * Math.cos(gammastar)) / Math.sin(gammastar))**2) * scale
                );
                
                // Create transformation matrix (column-major order for Three.js)
                this.reciprocalMatrix = new THREE.Matrix3();
                this.reciprocalMatrix.set(
                    this.aStarVec.x, this.bStarVec.x, this.cStarVec.x,
                    this.aStarVec.y, this.bStarVec.y, this.cStarVec.y,
                    this.aStarVec.z, this.bStarVec.z, this.cStarVec.z
                );
            }
            
            updateCellParamsDisplay() {
                if (!this.unitCellParams) return;
                
                const { a, b, c, alpha, beta, gamma } = this.unitCellParams;
                document.getElementById('cellParams').innerHTML = 
                    `Unit Cell: a=${a.toFixed(2)} b=${b.toFixed(2)} c=${c.toFixed(2)} α=${(alpha*180/Math.PI).toFixed(1)}° β=${(beta*180/Math.PI).toFixed(1)}° γ=${(gamma*180/Math.PI).toFixed(1)}°`;
            }
            
            updateVisualization() {
                if (!this.unitCellParams || !this.hklData || !this.reciprocalMatrix) return;
                
                // Remove existing points
                if (this.latticePoints) {
                    if (this.sceneGroup) {
                        this.sceneGroup.remove(this.latticePoints);
                    } else {
                        this.scene.remove(this.latticePoints);
                    }
                }
                
                const pointSize = parseFloat(document.getElementById('pointSize').value);
                const colorMode = document.querySelector('input[name="colorMode"]:checked').value;
                
                // Count multiplicity and get unique reflections
                const multiplicityMap = new Map();
                this.hklData.forEach(point => {
                    const key = `${point.h},${point.k},${point.l}`;
                    if (!multiplicityMap.has(key)) {
                        multiplicityMap.set(key, { count: 0, sources: new Set(), firstPoint: point });
                    }
                    multiplicityMap.get(key).count++;
                    multiplicityMap.get(key).sources.add(point.source);
                });
                
                const uniqueReflections = Array.from(multiplicityMap.entries()).map(([key, data]) => ({
                    ...data.firstPoint,
                    multiplicity: data.count,
                    sources: Array.from(data.sources)
                }));
                
                // Create geometry
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                if (colorMode === 'multiplicity') {
                    // Color by multiplicity
                    const maxMultiplicity = Math.max(...uniqueReflections.map(p => p.multiplicity));
                    const minMultiplicity = Math.min(...uniqueReflections.map(p => p.multiplicity));
                    
                    uniqueReflections.forEach(point => {
                        const hklVec = new THREE.Vector3(point.h, point.k, point.l);
                        hklVec.applyMatrix3(this.reciprocalMatrix);
                        positions.push(hklVec.x, hklVec.y, hklVec.z);
                        
                        const normalizedMult = (point.multiplicity - minMultiplicity) / (maxMultiplicity - minMultiplicity);
                        const color = new THREE.Color();
                        color.setHSL(normalizedMult * 0.8, 0.9, 0.6);
                        colors.push(color.r, color.g, color.b);
                    });
                } else {
                    // Color by source file
                    const fileColors = this.generateFileColors(this.loadedFiles);
                    
                    uniqueReflections.forEach(point => {
                        const hklVec = new THREE.Vector3(point.h, point.k, point.l);
                        hklVec.applyMatrix3(this.reciprocalMatrix);
                        positions.push(hklVec.x, hklVec.y, hklVec.z);
                        
                        // Use color of the first source file for this reflection
                        const sourceFile = point.source;
                        const color = fileColors[sourceFile] || new THREE.Color(0.5, 0.5, 0.5);
                        colors.push(color.r, color.g, color.b);
                    });
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: pointSize,
                    vertexColors: true,
                    sizeAttenuation: false,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.latticePoints = new THREE.Points(geometry, material);
                if (this.sceneGroup) {
                    this.sceneGroup.add(this.latticePoints);
                } else {
                    this.scene.add(this.latticePoints);
                }
                
                document.getElementById('reflectionCount').textContent = 
                    `Showing ${uniqueReflections.length} unique reflections from ${this.loadedFiles.length} file(s) (${this.hklData.length} total observations)`;
            }
            
            generateFileColors(fileNames) {
                const colors = {};
                const hueStep = 360 / fileNames.length;
                
                fileNames.forEach((fileName, index) => {
                    const hue = (index * hueStep) / 360;
                    colors[fileName] = new THREE.Color().setHSL(hue, 0.8, 0.6);
                });
                
                return colors;
            }
            
            updateFileList() {
                const fileListElement = document.getElementById('fileList');
                if (this.loadedFiles.length === 0) {
                    fileListElement.innerHTML = 'No files loaded';
                } else {
                    fileListElement.innerHTML = this.loadedFiles.map(filename => 
                        `• ${filename}`
                    ).join('<br>');
                }
            }
            
            autoCenter() {
                if (!this.latticePoints) return;
                
                // Calculate bounding box of all points
                const geometry = this.latticePoints.geometry;
                const positions = geometry.attributes.position.array;
                
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    const z = positions[i + 2];
                    
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                }
                
                // Calculate center and size
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                const centerZ = (minZ + maxZ) / 2;
                
                const sizeX = maxX - minX;
                const sizeY = maxY - minY;
                const sizeZ = maxZ - minZ;
                
                // Calculate appropriate distance
                const maxSize = Math.max(sizeX, sizeY, sizeZ);
                const distance = maxSize * 2; // Zoom out to see everything comfortably
                
                // Reset rotation
                this.currentQuaternion.set(0, 0, 0, 1);
                if (this.sceneGroup) {
                    this.sceneGroup.setRotationFromQuaternion(this.currentQuaternion);
                }
                
                // Set camera position (looking from a diagonal angle)
                this.camera.position.set(distance * 0.7, distance * 0.7, distance * 0.7);
                this.camera.lookAt(centerX, centerY, centerZ);
                
                // Update orthographic camera parameters
                const frustumSize = distance;
                this.camera.left = -frustumSize * window.innerWidth / window.innerHeight / 2;
                this.camera.right = frustumSize * window.innerWidth / window.innerHeight / 2;
                this.camera.top = frustumSize / 2;
                this.camera.bottom = -frustumSize / 2;
                this.camera.updateProjectionMatrix();
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the viewer when the page loads
        window.addEventListener('load', () => {
            new ReciprocalLatticeViewer();
        });
    </script>
</body>
</html>