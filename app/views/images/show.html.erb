<% content_for :title, "Image Details" %>

<style>
  .point-marker {
    transition: all 0.2s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  .point-marker:hover {
    transform: scale(1.2);
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
  }
  
  .point-crystal { 
    background-color: #007bff !important; 
  }
  
  .point-particle { 
    background-color: #6c757d !important; 
  }
  
  .point-droplet { 
    background-color: #17a2b8 !important; 
  }
  
  .point-other { 
    background-color: #ffc107 !important; 
  }
  
  #image-container {
    position: relative;
    display: inline-block;
  }
  
  #points-overlay {
    pointer-events: none;
  }
  
  #clickable-image {
    user-select: none;
  }
  
  .btn-xs {
    padding: 0.125rem 0.25rem;
    font-size: 0.75rem;
    border-radius: 0.125rem;
  }
  
  .bi-arrow-clockwise {
    animation: spin 1s linear infinite;
  }
  
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }
</style>

<div class="container">
<%# Navigation logic for keyboard shortcuts %>
<% wells = @well.plate.wells.includes(:images).order(:well_row, :well_column, :subwell) %>
<% well_index = wells.index(@well) %>

<%# Find previous/next wells that have images %>
<% prev_well = nil %>
<% if well_index && well_index > 0 %>
  <% (well_index - 1).downto(0) do |i| %>
    <% if wells[i].images.any? %>
      <% prev_well = wells[i] %>
      <% break %>
    <% end %>
  <% end %>
<% end %>

<% next_well = nil %>
<% if well_index && well_index < wells.size - 1 %>
  <% ((well_index + 1)...wells.size).each do |i| %>
    <% if wells[i].images.any? %>
      <% next_well = wells[i] %>
      <% break %>
    <% end %>
  <% end %>
<% end %>

<% images = @well.images.order(captured_at: :asc, created_at: :asc) %>
<% image_index = images.index(@image) %>
<% prev_image = images[image_index - 1] if image_index && image_index > 0 %>
<% next_image = images[image_index + 1] if image_index && image_index < images.size - 1 %>

<%# Debug output %>
<!-- Debug: Total wells: <%= wells.size %>, Current well index: <%= well_index %> -->
<!-- Debug: Prev well: <%= prev_well ? prev_well.well_label : '' %>, Next well: <%= next_well ? next_well.well_label : '' %> -->
<!-- Debug: Total images: <%= images.size %>, Current image index: <%= image_index %> -->
<!-- Debug: Prev image: <%= prev_image ? prev_image.id : '' %>, Next image: <%= next_image ? next_image.id : '' %> -->

<%# URLs for navigation %>
<% prevWellUrl = prev_well ? well_image_path(prev_well, prev_well.images.first) : nil %>
<% nextWellUrl = next_well ? well_image_path(next_well, next_well.images.first) : nil %>
<% prevImageUrl = prev_image ? well_image_path(@well, prev_image) : nil %>
<% nextImageUrl = next_image ? well_image_path(@well, next_image) : nil %>

<script>
window.imageNavigation = {
  prevWellUrl: <%= raw(prevWellUrl.to_json) %>,
  nextWellUrl: <%= raw(nextWellUrl.to_json) %>,
  prevImageUrl: <%= raw(prevImageUrl.to_json) %>,
  nextImageUrl: <%= raw(nextImageUrl.to_json) %>
};
</script>
  <div class="row">
    <div class="col-md-8">
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <h4 class="mb-0">Image for Well <%= @well.well_label_with_subwell %></h4>
          <div>
            <%= link_to 'Edit', edit_well_image_path(@well, @image), class: 'btn btn-outline-primary btn-sm me-2' %>
            <%= button_to 'Delete', well_image_path(@well, @image), method: :delete, 
                          class: 'btn btn-outline-danger btn-sm',
                          form: { style: "display: inline-block;" },
                          data: { confirm: "Are you sure you want to delete this image?" } %>
          </div>
        </div>
        <div class="card-body">
          <% if @image.file.attached? %>
            <div class="mb-4">
              <!-- Interactive Image Container -->
              <div id="image-container" class="position-relative d-inline-block">
                <% begin %>
                  <%= image_tag @image.file.variant(resize_to_limit: [800, 600]), 
                      id: "clickable-image",
                      class: "img-fluid img-thumbnail",
                      style: "cursor: crosshair;",
                      data: { 
                        image_id: @image.id,
                        well_id: @well.id,
                        pixel_width: @image.pixel_width,
                        pixel_height: @image.pixel_height
                      } %>
                  <!-- Points of Interest will be dynamically added here -->
                  <div id="points-overlay" class="position-absolute top-0 start-0 w-100 h-100 pointer-events-none"></div>
                <% rescue => e %>
                  <div class="alert alert-warning">
                    <p><strong>Could not display image preview:</strong> <%= e.message %></p>
                    <p>You can still <%= link_to 'download the original file', @image.file, target: '_blank' %></p>
                  </div>
                <% end %>
              </div>
              
              <!-- Point Selection Controls -->
              <div class="mt-3">
                <div class="btn-group me-3" role="group" aria-label="Point Type">
                  <input type="radio" class="btn-check" name="pointType" id="crystal" value="crystal" checked>
                  <label class="btn btn-outline-primary btn-sm" for="crystal">Crystal</label>
                  
                  <input type="radio" class="btn-check" name="pointType" id="particle" value="particle">
                  <label class="btn btn-outline-secondary btn-sm" for="particle">Particle</label>
                  
                  <input type="radio" class="btn-check" name="pointType" id="droplet" value="droplet">
                  <label class="btn btn-outline-info btn-sm" for="droplet">Droplet</label>
                  
                  <input type="radio" class="btn-check" name="pointType" id="other" value="other">
                  <label class="btn btn-outline-warning btn-sm" for="other">Other</label>
                </div>
                
                <button id="clear-points" class="btn btn-outline-danger btn-sm me-2">Clear All Points</button>
                <button id="toggle-points" class="btn btn-outline-dark btn-sm me-2">Hide Points</button>
                <button id="auto-segment" class="btn btn-outline-success btn-sm" 
                        data-well-id="<%= @well.id %>" 
                        data-image-id="<%= @image.id %>">
                  <i class="bi bi-magic"></i> Auto Segment
                </button>
              </div>
              
              <!-- Points List -->
              <div id="points-list" class="mt-3" style="display: none;">
                <h6>Points of Interest (<span id="points-count">0</span>)</h6>
                <div id="points-table-container">
                  <!-- Points table will be populated by JavaScript -->
                </div>
              </div>
            </div>
          <% end %>
          
          <div class="row">
            <div class="col-md-6">
              <h5>Image Properties</h5>
              <table class="table table-sm">
                <tr>
                  <td><strong>Dimensions:</strong></td>
                  <td><%= @image.pixel_width %>×<%= @image.pixel_height %> pixels</td>
                </tr>
                <tr>
                  <td><strong>Physical Size:</strong></td>
                  <td>
                    <% if @image.physical_width_mm && @image.physical_height_mm %>
                      <%= sprintf("%.3f", @image.physical_width_mm) %>×<%= sprintf("%.3f", @image.physical_height_mm) %> mm
                    <% else %>
                      Not calibrated
                    <% end %>
                  </td>
                </tr>
                <tr>
                  <td><strong>Pixel Size:</strong></td>
                  <td>
                    <% if @image.pixel_size_x_mm && @image.pixel_size_y_mm %>
                      <%= sprintf("%.6f", @image.pixel_size_x_mm) %>×<%= sprintf("%.6f", @image.pixel_size_y_mm) %> mm/pixel
                    <% else %>
                      Not calibrated
                    <% end %>
                  </td>
                </tr>
                <% if @image.captured_at %>
                <tr>
                  <td><strong>Captured:</strong></td>
                  <td><%= @image.captured_at.strftime("%Y-%m-%d %H:%M:%S") %></td>
                </tr>
                <% end %>
              </table>
            </div>
            
            <div class="col-md-6">
              <h5>Spatial Coordinates</h5>
              <table class="table table-sm">
                <tr>
                  <td><strong>Reference Point:</strong></td>
                  <td>
                    <% if @image.reference_x_mm && @image.reference_y_mm && @image.reference_z_mm %>
                      (<%= sprintf("%.3f", @image.reference_x_mm) %>, <%= sprintf("%.3f", @image.reference_y_mm) %>, <%= sprintf("%.3f", @image.reference_z_mm) %>)
                    <% else %>
                      Not set
                    <% end %>
                  </td>
                </tr>
                <tr>
                  <td><strong>Bounding Box:</strong></td>
                  <td>
                    <% bbox = @image.bounding_box %>
                    <% if bbox[:min_x] && bbox[:min_y] && bbox[:max_x] && bbox[:max_y] %>
                      X: <%= sprintf("%.3f", bbox[:min_x]) %> to <%= sprintf("%.3f", bbox[:max_x]) %><br>
                      Y: <%= sprintf("%.3f", bbox[:min_y]) %> to <%= sprintf("%.3f", bbox[:max_y]) %>
                    <% else %>
                      Not available (requires calibration)
                    <% end %>
                  </td>
                </tr>
              </table>
            </div>
          </div>
          
          <% if @image.description.present? %>
            <div class="mt-3">
              <h5>Description</h5>
              <p><%= @image.description %></p>
            </div>
          <% end %>
        </div>
      </div>
    </div>
    
    <div class="col-md-4">
      <div class="card">
        <div class="card-header">
          <h5 class="mb-0">Well Information</h5>
        </div>
        <div class="card-body">
          <p><strong>Well:</strong> <%= @well.well_label %></p>
          <p><strong>Plate:</strong> <%= @well.plate.barcode %></p>
          <p><strong>Total Images:</strong> <%= @well.images.count %></p>
          <%= link_to 'Back to Plate Grid', @well.plate, class: 'btn btn-outline-primary btn-sm' %>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// Interactive Image Viewer for Points of Interest
class InteractiveImageViewer {
  constructor(imageElement) {
    this.image = imageElement;
    this.overlay = document.getElementById('points-overlay');
    this.pointsList = document.getElementById('points-list');
    this.pointsCount = document.getElementById('points-count');
    this.pointsTableContainer = document.getElementById('points-table-container');
    this.clearPointsBtn = document.getElementById('clear-points');
    this.togglePointsBtn = document.getElementById('toggle-points');
    
    this.imageId = this.image.dataset.imageId;
    this.wellId = this.image.dataset.wellId;
    this.originalWidth = parseInt(this.image.dataset.pixelWidth);
    this.originalHeight = parseInt(this.image.dataset.pixelHeight);
    
    this.points = [];
    this.pointsVisible = true;
    
    this.init();
  }
  
  init() {
    this.setupEventListeners();
    this.loadExistingPoints();
  }
  
  setupEventListeners() {
    // Image click handler
    this.image.addEventListener('click', (e) => this.handleImageClick(e));
    
    // Control buttons
    this.clearPointsBtn.addEventListener('click', () => this.clearAllPoints());
    this.togglePointsBtn.addEventListener('click', () => this.togglePointsVisibility());
    
    // Auto-segment button
    const autoSegmentBtn = document.getElementById('auto-segment');
    if (autoSegmentBtn) {
      autoSegmentBtn.addEventListener('click', () => this.autoSegment());
    }
    
    // Image load handler to ensure we have correct dimensions
    this.image.addEventListener('load', () => this.refreshPointPositions());
  }
  
  handleImageClick(e) {
    const rect = this.image.getBoundingClientRect();
    const scaleX = this.originalWidth / this.image.clientWidth;
    const scaleY = this.originalHeight / this.image.clientHeight;
    
    // Calculate click position relative to image
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    
    // Round to nearest integer pixel
    const pixelX = Math.round(x);
    const pixelY = Math.round(y);
    
    // Get selected point type
    const pointType = document.querySelector('input[name="pointType"]:checked').value;
    
    this.createPoint(pixelX, pixelY, pointType);
  }
  
  async createPoint(pixelX, pixelY, pointType) {
    try {
      const response = await fetch(`/wells/${this.wellId}/images/${this.imageId}/point_of_interests`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
        },
        body: JSON.stringify({
          point_of_interest: {
            pixel_x: pixelX,
            pixel_y: pixelY,
            point_type: pointType
          }
        })
      });
      
      if (response.ok) {
        const point = await response.json();
        console.log('Created point:', point);
        this.addPointToDisplay(point);
        this.showNotification(`${pointType.charAt(0).toUpperCase() + pointType.slice(1)} marked at (${pixelX}, ${pixelY})`, 'success');
      } else {
        const errorText = await response.text();
        console.error('Server error response:', errorText);
        this.showNotification(`Error: ${errorText}`, 'error');
      }
    } catch (error) {
      console.error('Network error creating point:', error);
      this.showNotification(`Network error: ${error.message}`, 'error');
    }
  }
  
  async loadExistingPoints() {
    try {
      const response = await fetch(`/wells/${this.wellId}/images/${this.imageId}/point_of_interests.json`);
      if (response.ok) {
        this.points = await response.json();
        this.refreshDisplay();
      }
    } catch (error) {
      console.error('Error loading points:', error);
    }
  }
  
  addPointToDisplay(point) {
    this.points.push(point);
    this.refreshDisplay();
  }
  
  refreshDisplay() {
    this.clearPointMarkers();
    this.points.forEach(point => this.createPointMarker(point));
    this.updatePointsList();
    this.updatePointsCount();
  }
  
  createPointMarker(point) {
    if (!this.pointsVisible) return;
    
    const marker = document.createElement('div');
    marker.className = `point-marker point-${point.point_type}`;
    marker.dataset.pointId = point.id;
    
    // Position the marker
    const scaleX = this.image.clientWidth / this.originalWidth;
    const scaleY = this.image.clientHeight / this.originalHeight;
    
    const displayX = point.pixel_x * scaleX;
    const displayY = point.pixel_y * scaleY;
    
    marker.style.left = `${displayX - 6}px`; // Center the 12px marker
    marker.style.top = `${displayY - 6}px`;
    marker.style.position = 'absolute';
    marker.style.width = '12px';
    marker.style.height = '12px';
    marker.style.borderRadius = '50%';
    marker.style.border = '2px solid white';
    marker.style.cursor = 'pointer';
    marker.style.pointerEvents = 'auto';
    marker.style.zIndex = '10';
    
    // Color coding by type
    const colors = {
      crystal: '#007bff',    // Blue
      particle: '#6c757d',   // Gray
      droplet: '#17a2b8',    // Cyan
      other: '#ffc107'       // Yellow
    };
    marker.style.backgroundColor = colors[point.point_type] || colors.other;
    
    // Tooltip
    marker.title = `${point.point_type} at (${point.pixel_x}, ${point.pixel_y})`;
    if (point.description) {
      marker.title += ` - ${point.description}`;
    }
    
    // Click handler for deletion
    marker.addEventListener('click', (e) => {
      e.stopPropagation();
      this.deletePoint(point);
    });
    
    this.overlay.appendChild(marker);
  }
  
  async deletePoint(point) {
    if (!confirm(`Delete this ${point.point_type}?`)) return;
    
    try {
      const response = await fetch(`/wells/${this.wellId}/images/${this.imageId}/point_of_interests/${point.id}`, {
        method: 'DELETE',
        headers: {
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
        }
      });
      
      if (response.ok) {
        this.points = this.points.filter(p => p.id !== point.id);
        this.refreshDisplay();
        this.showNotification('Point deleted', 'success');
      } else {
        this.showNotification('Failed to delete point', 'error');
      }
    } catch (error) {
      console.error('Error deleting point:', error);
      this.showNotification('Network error occurred', 'error');
    }
  }
  
  clearPointMarkers() {
    const markers = this.overlay.querySelectorAll('.point-marker');
    markers.forEach(marker => marker.remove());
  }
  
  refreshPointPositions() {
    // Recalculate positions when image size changes
    this.refreshDisplay();
  }
  
  updatePointsList() {
    if (this.points.length === 0) {
      this.pointsList.style.display = 'none';
      return;
    }
    
    this.pointsList.style.display = 'block';
    
    const table = document.createElement('table');
    table.className = 'table table-sm table-striped';
    table.innerHTML = `
      <thead>
        <tr>
          <th>Type</th>
          <th>Pixel Coords</th>
          <th>Real World (mm)</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        ${this.points.map(point => `
          <tr>
            <td><span class="badge bg-${this.getTypeColor(point.point_type)}">${point.point_type}</span></td>
            <td>(${point.pixel_x}, ${point.pixel_y})</td>
            <td>(${this.formatCoordinate(point.real_world_x_mm)}, ${this.formatCoordinate(point.real_world_y_mm)})</td>
            <td>
              <button class="btn btn-outline-danger btn-xs" onclick="window.viewer.deletePointById(${point.id})">
                Delete
              </button>
            </td>
          </tr>
        `).join('')}
      </tbody>
    `;
    
    this.pointsTableContainer.innerHTML = '';
    this.pointsTableContainer.appendChild(table);
  }
  
  formatCoordinate(value) {
    if (value === null || value === undefined || isNaN(value)) {
      return 'N/A';
    }
    return parseFloat(value).toFixed(3);
  }
  
  deletePointById(pointId) {
    const point = this.points.find(p => p.id === pointId);
    if (point) {
      this.deletePoint(point);
    }
  }
  
  updatePointsCount() {
    this.pointsCount.textContent = this.points.length;
  }
  
  getTypeColor(type) {
    const colors = {
      crystal: 'primary',
      particle: 'secondary',
      droplet: 'info',
      other: 'warning'
    };
    return colors[type] || 'secondary';
  }
  
  async clearAllPoints() {
    if (this.points.length === 0) return;
    
    if (!confirm(`Delete all ${this.points.length} points?`)) return;
    
    try {
      const deletePromises = this.points.map(point => 
        fetch(`/wells/${this.wellId}/images/${this.imageId}/point_of_interests/${point.id}`, {
          method: 'DELETE',
          headers: {
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
          }
        })
      );
      
      await Promise.all(deletePromises);
      this.points = [];
      this.refreshDisplay();
      this.showNotification('All points cleared', 'success');
    } catch (error) {
      console.error('Error clearing points:', error);
      this.showNotification('Error clearing points', 'error');
    }
  }
  
  togglePointsVisibility() {
    this.pointsVisible = !this.pointsVisible;
    this.togglePointsBtn.textContent = this.pointsVisible ? 'Hide Points' : 'Show Points';
    
    if (this.pointsVisible) {
      this.refreshDisplay();
    } else {
      this.clearPointMarkers();
    }
  }

  async autoSegment() {
    const autoSegmentBtn = document.getElementById('auto-segment');
    
    // Disable button and show loading state
    autoSegmentBtn.disabled = true;
    const originalText = autoSegmentBtn.innerHTML;
    autoSegmentBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Segmenting...';
    
    try {
      const response = await fetch(`/wells/${this.wellId}/images/${this.imageId}/point_of_interests/auto_segment`, {
        method: 'POST',
        headers: {
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
        }
      });
      
      if (response.ok) {
        const result = await response.json();
        
        // Add the new points to our display
        result.points.forEach(point => {
          this.addPointToDisplay(point);
        });
        
        this.showNotification(
          `Auto-segmentation completed! Created ${result.points.length} points using ${result.model_used} model`, 
          'success'
        );
      } else {
        const errorData = await response.json();
        this.showNotification(`Auto-segmentation failed: ${errorData.error}`, 'error');
      }
    } catch (error) {
      console.error('Error during auto-segmentation:', error);
      this.showNotification(`Network error during auto-segmentation: ${error.message}`, 'error');
    } finally {
      // Re-enable button and restore original text
      autoSegmentBtn.disabled = false;
      autoSegmentBtn.innerHTML = originalText;
    }
  }

  showNotification(message, type = 'info') {
    // Create a simple notification
    const notification = document.createElement('div');
    notification.className = `alert alert-${type === 'error' ? 'danger' : 'success'} alert-dismissible fade show position-fixed`;
    notification.style.top = '20px';
    notification.style.right = '20px';
    notification.style.zIndex = '9999';
    notification.innerHTML = `
      ${message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;
    
    document.body.appendChild(notification);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.remove();
      }
    }, 5000);
  }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
  const clickableImage = document.getElementById('clickable-image');
  if (clickableImage) {
    window.viewer = new InteractiveImageViewer(clickableImage);
  }
  
  // Debug: log navigation object
  console.log('window.imageNavigation:', window.imageNavigation);

  // Keyboard navigation for wells and images
  document.addEventListener('keydown', function(e) {
    if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      e.preventDefault();
      console.log('Arrow key pressed:', e.key);
      const wellId = parseInt(clickableImage?.dataset.wellId);
      const imageId = parseInt(clickableImage?.dataset.imageId);
      if (!wellId || !imageId) {
        console.warn('Missing wellId or imageId:', { wellId, imageId });
        return;
      }
      function goTo(url) { window.location.href = url; }
      const nav = window.imageNavigation;
      if (!nav) {
        console.warn('window.imageNavigation is missing');
        return;
      }
      console.log('Navigation URLs:', nav);
      if (e.key === 'ArrowLeft' && nav.prevWellUrl) {
        console.log('Navigating to prevWellUrl:', nav.prevWellUrl);
        goTo(nav.prevWellUrl);
      } else if (e.key === 'ArrowRight' && nav.nextWellUrl) {
        console.log('Navigating to nextWellUrl:', nav.nextWellUrl);
        goTo(nav.nextWellUrl);
      } else if (e.key === 'ArrowUp' && nav.prevImageUrl) {
        console.log('Navigating to prevImageUrl:', nav.prevImageUrl);
        goTo(nav.prevImageUrl);
      } else if (e.key === 'ArrowDown' && nav.nextImageUrl) {
        console.log('Navigating to nextImageUrl:', nav.nextImageUrl);
        goTo(nav.nextImageUrl);
      } else {
        console.warn('No navigation URL for this key:', e.key);
      }
    }
  });
});
</script>
