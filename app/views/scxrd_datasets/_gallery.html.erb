<%# app/views/scxrd_datasets/_gallery.html.erb %>

<!-- SCXRD Diffraction Viewer Class - Visual Heatmap Version -->
<script>
// SCXRD Diffraction Viewer - Visual Heatmap Implementation
class ScxrdDiffractionViewer {
  constructor(containerId) {
    this.containerId = containerId;
    this.plotDiv = null;
    this.imageData = null;
    this.dimensions = null;
    this.metadata = null;
    this.heatmapInstance = null;
    this.currentIntensityRange = [0, 1000];
    this.currentZoom = 1;
    this.initialScale = 1;
  }

  getVisualHeatmap() {
    // Try both possible property names
    return window.VisualHeatmap || window.visualHeatmap;
  }

  async loadImageData(wellId, datasetId) {
    console.log(`Loading SCXRD image data for well ${wellId}, dataset ${datasetId}`);
    
    try {
      const url = `/wells/${wellId}/scxrd_datasets/${datasetId}/image_data`;
      console.log(`Fetching from: ${url}`);
      const response = await fetch(url);
      
      console.log(`Response status: ${response.status}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Received data:', { success: data.success, dimensions: data.dimensions, dataLength: data.image_data?.length });
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load image data');
      }
      
      this.imageData = data.image_data;
      this.dimensions = data.dimensions;
      this.metadata = data.metadata;
      
      console.log(`Loaded ${this.dimensions[0]}x${this.dimensions[1]} diffraction image`);
      return true;
    } catch (error) {
      console.error('Error loading SCXRD image data:', error);
      this.showError(error.message);
      return false;
    }
  }

  createSuperpixelHeatmapData() {
    if (!this.imageData || !this.dimensions) {
      console.error('Missing image data or dimensions for creating superpixel data');
      return [];
    }

    const [width, height] = this.dimensions;
    const binSize = 2;
    const binnedWidth = Math.ceil(width / binSize);
    const binnedHeight = Math.ceil(height / binSize);
    
    console.log(`Binning ${width}x${height} image into ${binnedWidth}x${binnedHeight} superpixels (${binSize}x${binSize} each)`);
    
    const heatmapData = [];
    
    // Create superpixel bins
    for (let binY = 0; binY < binnedHeight; binY++) {
      for (let binX = 0; binX < binnedWidth; binX++) {
        let totalIntensity = 0;
        let pixelCount = 0;
        
        // Sum intensities within this superpixel
        for (let py = binY * binSize; py < Math.min((binY + 1) * binSize, height); py++) {
          for (let px = binX * binSize; px < Math.min((binX + 1) * binSize, width); px++) {
            const value = this.imageData[py * width + px];
            totalIntensity += value;
            if (value > 0) pixelCount++;
          }
        }
        
        // Only include superpixels with non-zero intensity
        if (totalIntensity > 0) {
          heatmapData.push({
            x: binX * binSize, // Store original coordinates for now
            y: height - (binY * binSize), // Flip Y coordinate to correct orientation
            value: totalIntensity // Use sum of intensities for better visibility
          });
        }
      }
    }
    
    console.log(`Generated ${heatmapData.length} superpixel data points from ${width}x${height} image (${binnedWidth}x${binnedHeight} grid)`);
    console.log(`Reduction: ${(this.imageData.length - heatmapData.length).toLocaleString()} fewer points`);
    console.log(`Sample superpixel data:`, heatmapData.slice(0, 10));

    return heatmapData;
  }

  plotImage() {
    console.log('plotImage() called, checking Visual Heatmap availability...');
    console.log('window.VisualHeatmap:', window.VisualHeatmap);
    console.log('window.visualHeatmap:', window.visualHeatmap);
    console.log('typeof VisualHeatmap:', typeof window.VisualHeatmap);
    console.log('typeof visualHeatmap:', typeof window.visualHeatmap);
    
    if (!this.getVisualHeatmap()) {
      console.error('Visual Heatmap library not available');
      console.error('Available window properties:', Object.keys(window).filter(key => key.toLowerCase().includes('visual') || key.toLowerCase().includes('heatmap')));
      this.showError('Visual Heatmap library not loaded. Trying to reload...');
      
      // Try to load the library dynamically as fallback
      this.loadVisualHeatmapFallback();
      return;
    }

    this.plotDiv = document.getElementById(this.containerId);
    if (!this.plotDiv) {
      console.error(`Plot container '${this.containerId}' not found`);
      return;
    }

    if (!this.imageData || !this.dimensions) {
      this.showError('No image data available');
      return;
    }

    const [width, height] = this.dimensions;

    // Create container with heatmap div and controls
    this.plotDiv.innerHTML = `
      <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column;">
        <div id="${this.containerId}-canvas" style="width: 100%; flex: 1; border: 1px solid #dee2e6; overflow: hidden; background: #000;"></div>
        <div id="${this.containerId}-controls" style="height: 50px; padding: 5px; background: #f8f9fa; border-top: 1px solid #dee2e6; flex-shrink: 0;">
          <!-- Controls will be added here -->
        </div>
      </div>
    `;

    const heatmapContainer = document.getElementById(`${this.containerId}-canvas`);
    
    // Create superpixel heatmap data
    const heatmapData = this.createSuperpixelHeatmapData();

    // Calculate intensity statistics for better scaling
    const sortedValues = this.imageData.filter(v => v > 0).sort((a, b) => a - b);
    const maxIntensity = sortedValues[sortedValues.length - 1] || 1;
    const p99 = sortedValues[Math.floor(sortedValues.length * 0.99)] || maxIntensity;
    
    this.currentIntensityRange = [0, p99];

    console.log(`Creating visual heatmap with ${heatmapData.length} data points`);
    console.log(`Intensity range: 0 to ${p99} (max: ${maxIntensity})`);

    // Calculate scale factor to fit the card width
    const containerRect = heatmapContainer.getBoundingClientRect();
    const containerWidth = containerRect.width - 2; // Account for border
    const scaleFactor = Math.min(containerWidth / width, 1.0); // Don't scale up, only down
    
    console.log(`Container width: ${containerWidth}px, Image width: ${width}px, Scale factor: ${scaleFactor}`);
    
    // Apply scaling to coordinates while keeping top-left anchored
    const scaledHeatmapData = heatmapData.map(point => ({
      x: point.x * scaleFactor,
      y: point.y * scaleFactor,
      value: point.value
    }));

    // Create heatmap instance using Visual Heatmap API
    try {
      const HeatmapConstructor = this.getVisualHeatmap();
      
      console.log(`First few scaled data points:`, scaledHeatmapData.slice(0, 5));
      console.log(`Data value range: min=${Math.min(...scaledHeatmapData.map(d => d.value))}, max=${Math.max(...scaledHeatmapData.map(d => d.value))}`);
      
      // Visual Heatmap expects a container ID/selector, not canvas element
      this.heatmapInstance = HeatmapConstructor(`#${this.containerId}-canvas`, {
        size: 3, // Fixed size (2 * 1.5 = 3, since binSize was 2)
        max: p99,
        min: 0,
        intensity: 1.0, // Keep intensity at 1.0 (valid range is 0-1)
        opacity: 1.0, // Full opacity
        zoom: 1.0, // No zoom - render at natural size
        gradient: [{
          color: [0, 0, 0, 1.0],        // Black with transparency
          offset: 0.0
        }, {
          color: [255, 0, 0, 1.0],      // Reg
          offset: 0.33
        }, {
          color: [255, 255, 0, 1.0],    // Yellow
          offset: 0.66
        }, {
          color: [255, 255, 255, 1.0],      // White
          offset: 1.0
        }]
      });
      
      // Render the data
      console.log('Attempting to render data to heatmap instance...');
      console.log('Heatmap instance methods:', Object.keys(this.heatmapInstance));
      
      if (typeof this.heatmapInstance.renderData === 'function') {
        this.heatmapInstance.renderData(scaledHeatmapData);
        console.log('Data rendered with renderData()');
      } else if (typeof this.heatmapInstance.addData === 'function') {
        // Alternative API method
        this.heatmapInstance.addData(scaledHeatmapData);
        console.log('Data rendered with addData()');
      } else if (typeof this.heatmapInstance.setData === 'function') {
        // Another alternative API method
        this.heatmapInstance.setData({ data: scaledHeatmapData });
        console.log('Data rendered with setData()');
      } else {
        console.error('No suitable data rendering method found on heatmap instance');
        console.log('Available methods:', Object.keys(this.heatmapInstance));
      }
      
      // Force a render/repaint
      if (typeof this.heatmapInstance.render === 'function') {
        this.heatmapInstance.render();
      } else if (typeof this.heatmapInstance.repaint === 'function') {
        this.heatmapInstance.repaint();
      }
      
      // Store the initial scale for zoom controls (no scaling now)
      this.initialScale = 1.0;

      // Calculate average pixel intensity and set default to 10x average
      let totalIntensity = 0;
      let nonZeroPixels = 0;
      for (let i = 0; i < this.imageData.length; i++) {
        if (this.imageData[i] > 0) {
          totalIntensity += this.imageData[i];
          nonZeroPixels++;
        }
      }
      const averageIntensity = nonZeroPixels > 0 ? totalIntensity / nonZeroPixels : 100;
      this.defaultIntensity = averageIntensity * 10;
      this.maxSliderValue = this.defaultIntensity * 10;

      this.addControls();
      
      if (typeof this.heatmapInstance.setMax === 'function') {
        this.heatmapInstance.setMax(this.defaultIntensity);
        this.heatmapInstance.render();
        console.log(`Set initial intensity to: ${this.defaultIntensity.toFixed(2)} (10x average: ${averageIntensity.toFixed(2)})`);
      }
      
      // Add window resize handler to rescale the diffraction image
      this.setupResizeHandler();
      
      console.log('Visual heatmap created successfully');
      
    } catch (error) {
      console.error('Error creating visual heatmap:', error);
      this.showError('Failed to create diffraction image visualization');
    }
  }

  addControls() {
    const controlsDiv = document.getElementById(`${this.containerId}-controls`);
    if (!controlsDiv) return;

    const [width, height] = this.dimensions;
    // Fix: Don't spread large array - use manual calculation
    let maxIntensity = 0;
    for (let i = 0; i < this.imageData.length; i++) {
      if (this.imageData[i] > maxIntensity) {
        maxIntensity = this.imageData[i];
      }
    }

    const defaultValue = Math.round(this.defaultIntensity || 100);
    const maxValue = Math.round(this.maxSliderValue || 1000);
    
    controlsDiv.innerHTML = `
      <div class="d-flex align-items-center justify-content-center" style="font-size: 0.8rem;">
        <div class="d-flex align-items-center">
          <label class="me-2">Intensity:</label>
          <input type="range" id="${this.containerId}-intensity" class="form-range me-2" 
                 style="width: 120px;" min="1" max="${maxValue}" value="${defaultValue}">
          <span id="${this.containerId}-intensity-value">${defaultValue}</span>
        </div>
      </div>
    `;

    // Add event listener for intensity control
    const intensitySlider = document.getElementById(`${this.containerId}-intensity`);
    const intensityValue = document.getElementById(`${this.containerId}-intensity-value`);
    
    intensitySlider.addEventListener('input', (e) => {
      const sliderValue = parseInt(e.target.value);
      intensityValue.textContent = sliderValue;
      
      // Use the slider value directly as the intensity threshold (1-100)
      const newMax = sliderValue;
      this.currentIntensityRange[1] = newMax;
      
      // Update the heatmap's max value and re-render
      if (this.heatmapInstance) {
        console.log(`Intensity threshold set to: ${newMax}`);
        
        // Try different API methods for updating max value
        if (typeof this.heatmapInstance.setMax === 'function') {
          this.heatmapInstance.setMax(newMax);
        } else if (typeof this.heatmapInstance.configure === 'function') {
          this.heatmapInstance.configure({ max: newMax });
        } else if (typeof this.heatmapInstance.setConfig === 'function') {
          this.heatmapInstance.setConfig({ max: newMax });
        }
        
        // Force re-render
        if (typeof this.heatmapInstance.render === 'function') {
          this.heatmapInstance.render();
        } else if (typeof this.heatmapInstance.repaint === 'function') {
          this.heatmapInstance.repaint();
        }
        
        console.log(`Intensity threshold updated to: ${newMax}`);
      }
    });

    // Store reference for export function
    window[`scxrdViewer_${this.containerId.replace('-', '_')}`] = this;
  }

  setZoom(zoomLevel) {
    if (this.heatmapInstance) {
      // Apply zoom directly
      this.heatmapInstance.setZoom(zoomLevel);
      this.heatmapInstance.render();
      console.log(`Zoom set to ${zoomLevel}x`);
    }
  }

  loadVisualHeatmapFallback() {
    console.log('Attempting to load Visual Heatmap library dynamically...');
    
    // Try multiple CDN sources
    const cdnUrls = [
      'https://unpkg.com/visual-heatmap@2.2.0/dist/visualHeatmap.min.js',
      'https://cdn.jsdelivr.net/npm/visual-heatmap@2.2.0/dist/visualHeatmap.min.js',
      'https://cdnjs.cloudflare.com/ajax/libs/visual-heatmap/2.2.0/visualHeatmap.min.js'
    ];
    
    let currentIndex = 0;
    
    const tryNextCdn = () => {
      if (currentIndex >= cdnUrls.length) {
        this.showError('Unable to load Visual Heatmap library from any CDN source. Please check your internet connection.');
        return;
      }
      
      const script = document.createElement('script');
      script.src = cdnUrls[currentIndex];
      script.onload = () => {
        console.log(`Visual Heatmap loaded successfully from: ${cdnUrls[currentIndex]}`);
        console.log('window.VisualHeatmap now available:', !!window.VisualHeatmap);
        console.log('window.visualHeatmap now available:', !!window.visualHeatmap);
        // Retry plotting
        setTimeout(() => this.plotImage(), 100);
      };
      script.onerror = () => {
        console.error(`Failed to load from: ${cdnUrls[currentIndex]}`);
        currentIndex++;
        tryNextCdn();
      };
      document.head.appendChild(script);
    };
    
    tryNextCdn();
  }

  exportImage() {
    if (!this.heatmapInstance) {
      console.error('No heatmap instance available for export');
      return;
    }

    try {
      // Use Visual Heatmap's built-in export functionality
      this.heatmapInstance.toBlob('image/png', 0.92).then(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `scxrd_diffraction_${Date.now()}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        console.log('Image export completed');
      }).catch(error => {
        console.error('Error exporting image:', error);
      });
      
    } catch (error) {
      console.error('Error exporting image:', error);
    }
  }

  showError(message) {
    const plotDiv = document.getElementById(this.containerId);
    if (plotDiv) {
      plotDiv.innerHTML = `
        <div class="alert alert-danger m-3" role="alert">
          <h6>Error Loading Diffraction Image</h6>
          <p class="mb-0">${message}</p>
        </div>
      `;
    }
  }

  showLoading() {
    const plotDiv = document.getElementById(this.containerId);
    if (plotDiv) {
      plotDiv.innerHTML = `
        <div class="d-flex justify-content-center align-items-center" style="height: 30vw;">
          <div class="text-center">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading diffraction image...</div>
          </div>
        </div>
      `;
    }
  }

  setupResizeHandler() {
    // Remove any existing resize handler for this instance
    if (this.resizeHandler) {
      window.removeEventListener('resize', this.resizeHandler);
    }

    // Create a debounced resize handler
    let resizeTimeout;
    this.resizeHandler = () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        this.handleResize();
      }, 250); // Debounce for 250ms
    };

    // Add the resize event listener
    window.addEventListener('resize', this.resizeHandler);
    console.log('Resize handler setup for diffraction image viewer');
  }

  handleResize() {
    if (!this.heatmapInstance || !this.imageData || !this.dimensions) {
      console.log('Missing data for resize - heatmap instance, image data, or dimensions');
      return;
    }

    try {
      console.log('Handling window resize for diffraction image - completely redrawing');
      
      // Get the current container dimensions
      const container = document.getElementById(this.containerId);
      if (!container) {
        console.log('Container not found for resize');
        return;
      }

      // Get new container dimensions
      const containerRect = container.getBoundingClientRect();
      console.log(`New container dimensions: ${containerRect.width}x${containerRect.height}`);

      // Properly destroy the old heatmap instance and clear the canvas
      if (this.heatmapInstance) {
        // Try multiple destroy methods
        if (typeof this.heatmapInstance.destroy === 'function') {
          this.heatmapInstance.destroy();
        } else if (typeof this.heatmapInstance.clear === 'function') {
          this.heatmapInstance.clear();
        }
        this.heatmapInstance = null;
      }

      // Clear the canvas container completely
      const canvasContainer = document.getElementById(`${this.containerId}-canvas`);
      if (canvasContainer) {
        // Remove all child elements (canvas, etc.)
        canvasContainer.innerHTML = '';
        console.log('Cleared canvas container for resize');
      }

      // Get heatmap constructor
      const HeatmapConstructor = this.getVisualHeatmap();
      if (!HeatmapConstructor) {
        console.error('VisualHeatmap not available for resize');
        return;
      }

      // Recreate heatmap instance with new container size
      this.heatmapInstance = HeatmapConstructor(`#${this.containerId}-canvas`, {
        width: containerRect.width,
        height: containerRect.height,
        canvas: true,
        radius: Math.max(1, Math.min(containerRect.width, containerRect.height) * 0.015),
        maxOpacity: 0.8,
        minOpacity: 0.1,
        blur: 0.9,
        size: 3,
        gradient: [{
          color: [0, 0, 0, 1.0],        // Black with transparency
          offset: 0.0
        }, {
          color: [255, 0, 0, 1.0],      // Red
          offset: 0.33
        }, {
          color: [255, 255, 0, 1.0],    // Yellow
          offset: 0.66
        }, {
          color: [255, 255, 255, 1.0],  // White
          offset: 1.0
        }]
      });

      // Recalculate scaling factors for the new container size
      const [originalWidth, originalHeight] = this.dimensions;
      const scaleX = containerRect.width / originalWidth;
      const scaleY = containerRect.height / originalHeight;
      console.log(`Rescaling points: scaleX=${scaleX.toFixed(3)}, scaleY=${scaleY.toFixed(3)}`);

      // Recreate superpixel heatmap data with new scaling
      const heatmapData = this.createSuperpixelHeatmapData();
      
      // Scale the heatmap data points to new container size
      const scaledHeatmapData = heatmapData.map(point => ({
        x: point.x * scaleX,
        y: point.y * scaleY,
        value: point.value
      }));

      console.log(`Redrawing with ${scaledHeatmapData.length} rescaled data points`);

      // Apply the rescaled data to the new heatmap instance
      if (typeof this.heatmapInstance.renderData === 'function') {
        this.heatmapInstance.renderData(scaledHeatmapData);
      } else if (typeof this.heatmapInstance.addData === 'function') {
        scaledHeatmapData.forEach(point => this.heatmapInstance.addData(point));
      } else if (typeof this.heatmapInstance.setData === 'function') {
        this.heatmapInstance.setData({ data: scaledHeatmapData });
      }

      // Apply current intensity settings to the new instance
      if (typeof this.heatmapInstance.setMax === 'function') {
        this.heatmapInstance.setMax(this.defaultIntensity || 100);
      }

      // Render the new heatmap
      if (typeof this.heatmapInstance.render === 'function') {
        this.heatmapInstance.render();
      } else if (typeof this.heatmapInstance.repaint === 'function') {
        this.heatmapInstance.repaint();
      }

      console.log('Diffraction image completely redrawn and rescaled successfully');
      
    } catch (error) {
      console.error('Error handling resize:', error);
    }
  }

  destroy() {
    // Clean up resize handler when viewer is destroyed
    if (this.resizeHandler) {
      window.removeEventListener('resize', this.resizeHandler);
      this.resizeHandler = null;
    }
  }
}

// Make available globally
window.ScxrdDiffractionViewer = ScxrdDiffractionViewer;
console.log('ScxrdDiffractionViewer (Visual Heatmap) defined inline');



// Card Toggle Functionality
class ScxrdCardToggler {
  constructor() {
    this.maxMaximizedCards = 3;
    this.maximizedHistory = []; // Track order of maximization
    this.initializeToggleHandlers();
  }

  initializeToggleHandlers() {
    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', () => {
      this.setupCardToggles();
    });
    
    // Also setup immediately in case DOM is already ready
    if (document.readyState === 'loading') {
      // DOM is still loading
    } else {
      this.setupCardToggles();
    }
  }

  setupCardToggles() {
    const cardContainers = document.querySelectorAll('[data-card-id]');
    cardContainers.forEach(container => {
      const header = container.querySelector('.card-header');
      const cardId = container.getAttribute('data-card-id');
      
      if (header) {
        header.style.cursor = 'pointer';
        header.style.userSelect = 'none';
        header.addEventListener('click', () => this.toggleCard(cardId));
        
        // Add visual indication that it's clickable
        header.innerHTML += ' <i class="fas fa-chevron-up toggle-icon ms-1" style="font-size: 0.8em; transition: transform 0.3s ease;"></i>';
      }
    });
    
    // Initialize default states
    this.initializeDefaultStates();
  }

  initializeDefaultStates() {
    // Initialize the first 3 cards as maximized
    const allCards = document.querySelectorAll('[data-card-id]');
    allCards.forEach((container, index) => {
      const cardId = container.getAttribute('data-card-id');
      if (index < 3 && !container.classList.contains('minimized')) {
        // Add to maximized history for the first 3 cards
        this.maximizedHistory.push(cardId);
      } else if (container.classList.contains('minimized')) {
        // Ensure minimized cards have the right styling
        this.applyMinimizedStyling(container);
      }
    });
  }

  applyMinimizedStyling(container) {
    const headerText = container.querySelector('.card-header small');
    const toggleIcon = container.querySelector('.toggle-icon');
    
    if (headerText) {
      headerText.classList.add('minimized-text');
    }
    if (toggleIcon) {
      toggleIcon.style.transform = 'rotate(180deg)';
    }
  }

  toggleCard(cardId) {
    const container = document.querySelector(`[data-card-id="${cardId}"]`);
    if (!container) return;

    const isMinimized = container.classList.contains('minimized');
    
    if (isMinimized) {
      this.maximizeCard(container, cardId);
    } else {
      this.minimizeCard(container, cardId);
    }
  }

  minimizeCard(container, cardId) {
    const cardBody = container.querySelector('.card-body');
    const toggleIcon = container.querySelector('.toggle-icon');
    
    // Remove from maximized history
    this.maximizedHistory = this.maximizedHistory.filter(id => id !== cardId);
    
    container.classList.add('minimized');
    
    // Animate to vertical strip
    container.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
    container.style.width = '60px';
    container.style.minWidth = '60px';
    container.style.zIndex = '10';
    
    // Hide card body with fade
    if (cardBody) {
      cardBody.style.transition = 'opacity 0.2s ease';
      cardBody.style.opacity = '0';
      setTimeout(() => {
        cardBody.style.display = 'none';
      }, 200);
    }
    
    // Rotate icon
    if (toggleIcon) {
      toggleIcon.style.transform = 'rotate(180deg)';
    }
    
    // Add minimized class for CSS styling
    const headerText = container.querySelector('.card-header small');
    if (headerText) {
      setTimeout(() => {
        headerText.classList.add('minimized-text');
      }, 200);
    }
  }

  maximizeCard(container, cardId) {
    // Check if we need to minimize the least recently maximized card
    if (this.maximizedHistory.length >= this.maxMaximizedCards) {
      const oldestCardId = this.maximizedHistory[0];
      const oldestContainer = document.querySelector(`[data-card-id="${oldestCardId}"]`);
      if (oldestContainer && !oldestContainer.classList.contains('minimized')) {
        this.minimizeCard(oldestContainer, oldestCardId);
      }
    }
    
    // Add to maximized history
    this.maximizedHistory = this.maximizedHistory.filter(id => id !== cardId); // Remove if already exists
    this.maximizedHistory.push(cardId); // Add to end
    
    const cardBody = container.querySelector('.card-body');
    const toggleIcon = container.querySelector('.toggle-icon');
    
    container.classList.remove('minimized');
    
    // Restore card size
    container.style.transition = 'all 0.4s cubic-bezier(0.4, 0, 0.2, 1)';
    container.style.width = '';
    container.style.minWidth = '';
    container.style.zIndex = '';
    
    // Restore header text
    const headerText = container.querySelector('.card-header small');
    if (headerText) {
      headerText.classList.remove('minimized-text');
    }
    
    // Show card body with fade in
    if (cardBody) {
      setTimeout(() => {
        cardBody.style.display = '';
        cardBody.style.transition = 'opacity 0.3s ease';
        cardBody.style.opacity = '1';
      }, 200);
    }
    
    // Rotate icon back
    if (toggleIcon) {
      toggleIcon.style.transform = 'rotate(0deg)';
    }
  }
}

// Initialize card toggler
window.scxrdCardToggler = new ScxrdCardToggler();

// Inline Reciprocal Lattice Viewer Class
class ScxrdReciprocalLatticeViewer {
  constructor(containerId) {
    this.containerId = containerId;
    this.container = null;
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.controls = null;
    this.points = null;
    this.dataPoints = [];
    this.statistics = {};
    
    // Material and visualization settings
    this.pointSize = 2;
    this.intensityRange = [0, 100];
    
    // Animation and interaction
    this.animationId = null;
    this.isAnimating = false;
    
    // Three.js availability check
    this.threeAvailable = false;
    this.checkThreeJsAvailability();
  }

  checkThreeJsAvailability() {
    if (typeof THREE !== 'undefined') {
      this.threeAvailable = true;
      console.log('Three.js is already available');
    } else {
      console.log('Three.js not found, loading from CDN...');
      this.loadThreeJs();
      
      // Set a timeout for loading Three.js
      setTimeout(() => {
        if (!this.threeAvailable && typeof THREE === 'undefined') {
          console.warn('Three.js loading timed out after 15 seconds, will use fallback visualization');
        }
      }, 15000); // 15 second timeout
    }
  }

  loadThreeJs() {
    // Use traditional script loading approach with better CDN selection
    console.log('Loading Three.js using traditional script approach...');
    
    // Try unpkg first as it seems more reliable
    const threeScript = document.createElement('script');
    threeScript.src = 'https://unpkg.com/three@0.157.0/build/three.min.js';
    threeScript.onload = () => {
      console.log('Three.js loaded successfully from unpkg');
      this.threeAvailable = true;
      
      // Try to load OrbitControls (optional)
      const controlsScript = document.createElement('script');
      controlsScript.src = 'https://unpkg.com/three@0.157.0/examples/js/controls/OrbitControls.js';
      controlsScript.onload = () => {
        console.log('OrbitControls loaded successfully');
      };
      controlsScript.onerror = () => {
        console.log('OrbitControls not loaded, will use basic mouse controls');
      };
      document.head.appendChild(controlsScript);
      
      // Notify that Three.js is ready
      window.dispatchEvent(new CustomEvent('threeJsLoaded'));
    };
    
    threeScript.onerror = () => {
      console.error('Failed to load Three.js from unpkg, trying jsdelivr...');
      
      // Fallback to jsdelivr
      const fallbackScript = document.createElement('script');
      fallbackScript.src = 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js';
      fallbackScript.onload = () => {
        console.log('Three.js loaded from jsdelivr fallback');
        this.threeAvailable = true;
        window.dispatchEvent(new CustomEvent('threeJsLoaded'));
      };
      fallbackScript.onerror = () => {
        console.error('All Three.js loading attempts failed');
        // Don't show error immediately, let the timeout handle it
      };
      document.head.appendChild(fallbackScript);
    };
    
    document.head.appendChild(threeScript);
    
    // Listen for the Three.js loaded event
    window.addEventListener('threeJsLoaded', () => {
      this.threeAvailable = true;
      console.log('Three.js is ready for use');
    }, { once: true });
  }

  async loadPeakTableData(wellId, datasetId) {
    console.log(`Loading reciprocal lattice data for well ${wellId}, dataset ${datasetId}`);
    
    // Store these for fallback use
    this.wellId = wellId;
    this.datasetId = datasetId;
    
    try {
      const url = `/wells/${wellId}/scxrd_datasets/${datasetId}/peak_table_data`;
      console.log(`Fetching from: ${url}`);
      const response = await fetch(url);
      
      console.log(`Response status: ${response.status}`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Received data:', { 
        success: data.success, 
        dataPointsLength: data.data_points?.length,
        statistics: data.statistics 
      });
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to load peak table data');
      }
      
      this.dataPoints = data.data_points;
      this.statistics = data.statistics;
      
      console.log(`Loaded ${this.dataPoints.length} reciprocal lattice points`);
      return true;
    } catch (error) {
      console.error('Error loading reciprocal lattice data:', error);
      this.showError(error.message);
      return false;
    }
  }

  plotReciprocalLattice() {
    console.log('plotReciprocalLattice() called');
    
    if (!this.threeAvailable && typeof THREE === 'undefined') {
      console.log('Waiting for Three.js to load...');
      
      // Check multiple times with increasing intervals
      let attempts = 0;
      const checkThreeJs = () => {
        attempts++;
        if (typeof THREE !== 'undefined') {
          console.log('Three.js detected, proceeding with 3D visualization');
          this.threeAvailable = true;
          this.plotReciprocalLattice();
        } else if (attempts < 10) { // Try for up to 20 seconds
          setTimeout(checkThreeJs, 2000);
        } else {
          console.log('Three.js loading timed out after 20 seconds');
          this.showFallbackVisualization();
        }
      };
      
      setTimeout(checkThreeJs, 1000); // Start checking after 1 second
      return;
    }
    
    // If we get here, Three.js should be available
    if (typeof THREE !== 'undefined') {
      this.threeAvailable = true;
    }

    this.container = document.getElementById(this.containerId);
    if (!this.container) {
      console.error(`Container '${this.containerId}' not found`);
      return;
    }

    if (!this.dataPoints || this.dataPoints.length === 0) {
      this.showError('No reciprocal lattice data available');
      return;
    }

    console.log(`Setting up 3D visualization with ${this.dataPoints.length} points`);

    // Clear existing content
    this.container.innerHTML = '';

    // Create container structure with explicit full width
    this.container.innerHTML = `
      <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; box-sizing: border-box;">
        <div id="${this.containerId}-canvas" style="width: 100%; flex: 1 1 auto; overflow: hidden; background: #000; min-height: 0; box-sizing: border-box;"></div>
        <div id="${this.containerId}-controls" style="height: 60px; padding: 8px; background: #f8f9fa; border-top: 1px solid #dee2e6; flex-shrink: 0; width: 100%; box-sizing: border-box;">
          <!-- Controls will be added here -->
        </div>
      </div>
    `;

    const canvasContainer = document.getElementById(`${this.containerId}-canvas`);
    
    // Force container to take full width
    canvasContainer.style.width = '100%';
    canvasContainer.style.height = '100%';
    
    // Wait a moment for layout to settle, then get dimensions
    setTimeout(() => {
      const containerRect = canvasContainer.getBoundingClientRect();
      console.log(`Canvas container dimensions: ${containerRect.width}x${containerRect.height}`);

      // Initialize Three.js scene
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x000011);

      // Setup orthographic camera for technical/scientific visualization
      const aspect = containerRect.width / containerRect.height;
      const frustumSize = 5;
      this.camera = new THREE.OrthographicCamera(
        frustumSize * aspect / -2, 
        frustumSize * aspect / 2, 
        frustumSize / 2, 
        frustumSize / -2,
        0.1, 
        1000
      );
      
      // Set default zoom level to 10
      this.camera.zoom = 10;
      this.camera.updateProjectionMatrix();

      // Setup renderer
      this.renderer = new THREE.WebGLRenderer({ antialias: true });
      this.renderer.setSize(containerRect.width, containerRect.height);
      this.renderer.setPixelRatio(window.devicePixelRatio);
      
      // Ensure renderer canvas takes full width
      this.renderer.domElement.style.width = '100%';
      this.renderer.domElement.style.height = '100%';
      
      canvasContainer.appendChild(this.renderer.domElement);

      // Continue with the rest of the setup
      this.continueSetup();
    }, 100);
  }

  continueSetup() {

    // Setup camera controls if available - check multiple possible locations
    let OrbitControlsClass = null;
    if (typeof THREE.OrbitControls !== 'undefined') {
      OrbitControlsClass = THREE.OrbitControls;
    } else if (typeof window.OrbitControls !== 'undefined') {
      OrbitControlsClass = window.OrbitControls;
    }
    
    if (OrbitControlsClass) {
      try {
        this.controls = new OrbitControlsClass(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        console.log('OrbitControls initialized successfully');
      } catch (error) {
        console.warn('Failed to initialize OrbitControls:', error);
        this.addBasicMouseControls();
      }
    } else {
      console.log('OrbitControls not available, using basic mouse interaction');
      this.addBasicMouseControls();
    }

    // Add coordinate axes
    this.addAxes();

    // Create point cloud from reciprocal lattice data
    this.createPointCloud();

    // Position camera
    this.positionCamera();

    // Add controls
    this.addControls();

    // Start animation loop
    this.startAnimation();

    // Handle window resize
    this.setupResizeHandler();

    console.log('3D reciprocal lattice visualization created successfully');
  }

  addAxes() {
    const axesHelper = new THREE.AxesHelper(2);
    this.scene.add(axesHelper);
  }

  addBasicMouseControls() {
    // Basic mouse rotation controls as fallback
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    
    this.renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    this.renderer.domElement.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaMove = {
        x: e.clientX - previousMousePosition.x,
        y: e.clientY - previousMousePosition.y
      };
      
      // Rotate camera around the center
      const spherical = new THREE.Spherical();
      spherical.setFromVector3(this.camera.position);
      
      spherical.theta -= deltaMove.x * 0.01;
      spherical.phi += deltaMove.y * 0.01;
      spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
      
      this.camera.position.setFromSpherical(spherical);
      this.camera.lookAt(0, 0, 0);
      
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });
    
    this.renderer.domElement.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    // Mouse wheel for zoom - adjust orthographic camera zoom
    this.renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      const scale = e.deltaY > 0 ? 1.1 : 0.9;
      
      // For orthographic camera, adjust the frustum size instead of position
      const aspect = this.renderer.domElement.width / this.renderer.domElement.height;
      let frustumSize = (this.camera.right - this.camera.left) / aspect;
      frustumSize *= scale;
      
      // Limit zoom
      frustumSize = Math.max(0.5, Math.min(20, frustumSize));
      
      this.camera.left = frustumSize * aspect / -2;
      this.camera.right = frustumSize * aspect / 2;
      this.camera.top = frustumSize / 2;
      this.camera.bottom = frustumSize / -2;
      this.camera.updateProjectionMatrix();
    });
    
    console.log('Basic mouse controls added');
  }

  createPointCloud() {
    // Calculate data range for normalization
    const rValues = this.dataPoints.map(p => p.r);
    const rMin = Math.min(...rValues);
    const rMax = Math.max(...rValues);
    
    console.log(`R value range: ${rMin} to ${rMax}`);

    // Create geometry and materials
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    const colors = [];
    
    // Convert data points to Three.js format
    this.dataPoints.forEach(point => {
      // Add position (scaling down for better visualization)
      positions.push(point.x * 0.1, point.y * 0.1, point.z * 0.1);
      
      // Add color based on r value (intensity)
      const normalizedR = (point.r - rMin) / (rMax - rMin);
      const color = this.getColorFromValue(normalizedR);
      colors.push(color.r, color.g, color.b);
    });

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    // Create point material
    const material = new THREE.PointsMaterial({
      size: this.pointSize,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true
    });

    // Create points mesh
    this.points = new THREE.Points(geometry, material);
    this.scene.add(this.points);

    console.log(`Created point cloud with ${positions.length / 3} points`);
  }

  getColorFromValue(normalizedValue) {
    // Light blue color for all points
    return { r: 0.5, g: 0.8, b: 1.0 };
  }

  positionCamera() {
    // Position camera for good view of the data
    if (this.statistics.x && this.statistics.y && this.statistics.z) {
      const centerX = this.statistics.x.mean * 0.1;
      const centerY = this.statistics.y.mean * 0.1;
      const centerZ = this.statistics.z.mean * 0.1;
      
      this.camera.position.set(centerX + 2, centerY + 2, centerZ + 2);
      this.camera.lookAt(centerX, centerY, centerZ);
      
      if (this.controls) {
        this.controls.target.set(centerX, centerY, centerZ);
      }
    } else {
      this.camera.position.set(2, 2, 2);
      this.camera.lookAt(0, 0, 0);
    }
  }

  addControls() {
    const controlsDiv = document.getElementById(`${this.containerId}-controls`);
    if (!controlsDiv) return;

    // Calculate initial intensity range
    const rValues = this.dataPoints.map(p => p.r);
    const rMin = Math.min(...rValues);
    const rMax = Math.max(...rValues);

    controlsDiv.innerHTML = `
      <div class="d-flex align-items-center justify-content-center gap-3" style="font-size: 0.8rem;">
        <div class="d-flex align-items-center">
          <button id="${this.containerId}-reset" class="btn btn-sm btn-outline-primary">Reset View</button>
        </div>
        <div class="d-flex align-items-center">
          <span class="small text-muted">${this.dataPoints.length} points</span>
        </div>
      </div>
    `;

    // Add event listeners
    this.setupControlEventListeners();
  }

  setupControlEventListeners() {
    // Reset view button
    const resetButton = document.getElementById(`${this.containerId}-reset`);
    if (resetButton) {
      resetButton.addEventListener('click', () => {
        this.positionCamera();
        if (this.controls) {
          this.controls.reset();
        }
      });
    }
  }

  startAnimation() {
    this.isAnimating = true;
    this.animate();
  }

  animate() {
    if (!this.isAnimating) return;

    this.animationId = requestAnimationFrame(() => this.animate());

    // Update controls
    if (this.controls) {
      this.controls.update();
    }

    // Render scene
    this.renderer.render(this.scene, this.camera);
  }

  setupResizeHandler() {
    const resizeObserver = new ResizeObserver(entries => {
      for (let entry of entries) {
        const { width, height } = entry.contentRect;
        console.log(`Canvas resize detected: ${width}x${height}`);
        if (width > 0 && height > 0) {
          // Update orthographic camera frustum
          const aspect = width / height;
          const frustumSize = 5;
          this.camera.left = frustumSize * aspect / -2;
          this.camera.right = frustumSize * aspect / 2;
          this.camera.top = frustumSize / 2;
          this.camera.bottom = frustumSize / -2;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(width, height);
          
          // Ensure canvas style matches
          this.renderer.domElement.style.width = '100%';
          this.renderer.domElement.style.height = '100%';
        }
      }
    });

    const canvasContainer = document.getElementById(`${this.containerId}-canvas`);
    if (canvasContainer) {
      resizeObserver.observe(canvasContainer);
    }
  }

  showError(message) {
    const container = document.getElementById(this.containerId);
    if (container) {
      container.innerHTML = `
        <div class="alert alert-danger m-3" role="alert">
          <h6>Error Loading Reciprocal Lattice</h6>
          <p class="mb-0">${message}</p>
        </div>
      `;
    }
  }

  showLoading() {
    const container = document.getElementById(this.containerId);
    if (container) {
      container.innerHTML = `
        <div class="d-flex justify-content-center align-items-center" style="height: 30vw;">
          <div class="text-center">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-2">Loading reciprocal lattice...</div>
          </div>
        </div>
      `;
    }
  }

  showFallbackVisualization() {
    console.log('Showing fallback visualization');
    const container = document.getElementById(this.containerId);
    if (!container) return;

    // Show a simple 2D projection of the data as fallback
    const stats = this.statistics;
    const pointCount = this.dataPoints.length;
    
    container.innerHTML = `
      <div class="p-3">
        <div class="alert alert-warning mb-3">
          <h6><i class="fas fa-exclamation-triangle me-2"></i>3D Viewer Unavailable</h6>
          <p class="mb-0">Showing data summary instead. The 3D visualization requires Three.js library.</p>
        </div>
        
        <div class="row">
          <div class="col-md-6">
            <h6>Reciprocal Lattice Data</h6>
            <ul class="list-unstyled">
              <li><strong>Points:</strong> ${pointCount.toLocaleString()}</li>
              ${stats.x ? `<li><strong>X Range:</strong> ${stats.x.min.toFixed(3)} to ${stats.x.max.toFixed(3)}</li>` : ''}
              ${stats.y ? `<li><strong>Y Range:</strong> ${stats.y.min.toFixed(3)} to ${stats.y.max.toFixed(3)}</li>` : ''}
              ${stats.z ? `<li><strong>Z Range:</strong> ${stats.z.min.toFixed(3)} to ${stats.z.max.toFixed(3)}</li>` : ''}
              ${stats.r ? `<li><strong>Intensity Range:</strong> ${stats.r.min.toFixed(3)} to ${stats.r.max.toFixed(3)}</li>` : ''}
            </ul>
          </div>
          <div class="col-md-6">
            <h6>Actions</h6>
            <a href="/wells/${this.wellId}/scxrd_datasets/${this.datasetId}/download_peak_table" 
               class="btn btn-success btn-sm">
              <i class="fas fa-download me-1"></i>Download Peak Table
            </a>
            <button class="btn btn-outline-primary btn-sm ms-2" onclick="location.reload()">
              <i class="fas fa-redo me-1"></i>Retry 3D View
            </button>
          </div>
        </div>
      </div>
    `;
  }

  destroy() {
    // Stop animation
    this.isAnimating = false;
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }

    // Dispose of Three.js objects
    if (this.points) {
      this.points.geometry.dispose();
      this.points.material.dispose();
    }
    
    if (this.renderer) {
      this.renderer.dispose();
    }

    // Clear container
    const container = document.getElementById(this.containerId);
    if (container) {
      container.innerHTML = '';
    }
  }
}

// Make available globally
window.ScxrdReciprocalLatticeViewer = ScxrdReciprocalLatticeViewer;
console.log('ScxrdReciprocalLatticeViewer defined inline');
</script>

<style>
/* Card toggle animations and styles */
.scxrd-card-container {
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  position: relative;
  align-self: flex-start;
}

.scxrd-card-container.minimized {
  flex: 0 0 60px !important;
  max-width: 60px !important;
  height: 30vw !important;
}

.scxrd-card-container.minimized .card {
  height: 30vw !important;
  display: flex !important;
  flex-direction: column !important;
}

.scxrd-card-container.minimized .card-header {
  height: 100% !important;
  flex: 1 1 100% !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  padding: 8px 4px !important;
  margin: 0 !important;
  border: none !important;
}

.scxrd-card-container.minimized .card-body {
  display: none !important;
}

.minimized-text {
  writing-mode: vertical-rl !important;
  text-orientation: mixed !important;
  font-size: 0.75em !important;
  padding: 8px 0 !important;
  transition: all 0.3s ease !important;
}

.scxrd-card-container:not(.minimized) {
  flex: 0 0 28vw;
  width: 28vw;
  height: 100%;
  float: left;
}

.card-header:hover {
  background-color: #e9ecef !important;
}

.toggle-icon {
  transition: transform 0.3s ease;
}

/* Ensure smooth flex transitions */
.scxrd-main-row {
  transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex;
  flex-wrap: wrap;
  align-items: flex-start;
  justify-content: flex-start;
}
</style>

<script>
// Define function in global scope for SCXRD dataset switching
window.showScxrdDatasetInMain = function(datasetId, experimentName, datasetUrl) {
  console.log('showScxrdDatasetInMain called with:', datasetId, experimentName, datasetUrl);
  
  // Update the main display panels
  fetch(`/wells/<%= @well.id %>/scxrd_datasets/${datasetId}`, {
    headers: { 'Accept': 'application/json' }
  })
    .then(response => response.json())
    .then(data => {
      // Update first diffraction image panel with interactive viewer
      const imagePanel = document.getElementById('scxrd-first-image-panel');
      if (data.has_first_image) {
        // Show loading state
        imagePanel.innerHTML = `
          <div class="d-flex justify-content-center align-items-center h-100">
            <div class="text-center">
              <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <div class="mt-2 small">Loading diffraction image...</div>
            </div>
          </div>
        `;
        
        // Load and display interactive diffraction viewer
        console.log('ScxrdDiffractionViewer available:', !!window.ScxrdDiffractionViewer);
        console.log('Visual Heatmap available:', !!window.VisualHeatmap);
        if (window.ScxrdDiffractionViewer) {
          // First, replace panel content with plot container
          imagePanel.innerHTML = `
            <div class="position-relative h-100">
              <div id="scxrd-diffraction-plot" style="width: 100%; height: 100%;"></div>
            </div>
          `;
          
          // Now create viewer and load data
          setTimeout(() => {
            const viewer = new window.ScxrdDiffractionViewer('scxrd-diffraction-plot');
            viewer.showLoading();
            viewer.loadImageData(<%= @well.id %>, datasetId).then(success => {
              if (success) {
                viewer.plotImage();
              }
            });
          }, 100);
        } else {
          // Fallback if ScxrdDiffractionViewer is not available
          imagePanel.innerHTML = `
            <div class="text-center p-3">
              <i class="fas fa-camera fa-3x mb-3 text-primary"></i>
              <h6>First Frame</h6>
              <p class="text-muted small">Size: ${data.first_image_size}</p>
              <a href="/wells/<%= @well.id %>/scxrd_datasets/${datasetId}/download_first_image" 
                 class="btn btn-sm btn-primary">
                <i class="fas fa-download me-1"></i>Download
              </a>
            </div>
          `;
        }
      } else {
        imagePanel.innerHTML = `
          <div class="text-center p-3 text-muted">
            <i class="fas fa-camera fa-3x mb-3"></i>
            <h6>First Frame</h6>
            <p class="small">Not available</p>
          </div>
        `;
      }

      // Update peak table panel with interactive reciprocal lattice viewer
      const peakPanel = document.getElementById('scxrd-peak-table-panel');
      if (data.has_peak_table) {
        // Show loading state
        peakPanel.innerHTML = `
          <div class="d-flex justify-content-center align-items-center h-100">
            <div class="text-center">
              <div class="spinner-border text-success" role="status">
                <span class="visually-hidden">Loading...</span>
              </div>
              <div class="mt-2 small">Loading reciprocal lattice...</div>
            </div>
          </div>
        `;
        
        // Load and display interactive reciprocal lattice viewer
        console.log('ScxrdReciprocalLatticeViewer available:', !!window.ScxrdReciprocalLatticeViewer);
        if (window.ScxrdReciprocalLatticeViewer) {
          // First, replace panel content with plot container
          peakPanel.innerHTML = `
            <div class="position-relative" style="width: 29vw; height: 29vw;">
              <div id="scxrd-reciprocal-lattice-plot" style="width: 100%; height: 100%;"></div>
            </div>
          `;
          
          // Now create viewer and load data
          setTimeout(() => {
            const viewer = new window.ScxrdReciprocalLatticeViewer('scxrd-reciprocal-lattice-plot');
            viewer.showLoading();
            viewer.loadPeakTableData(<%= @well.id %>, datasetId).then(success => {
              if (success) {
                viewer.plotReciprocalLattice();
              }
            });
          }, 100);
        } else {
          // Fallback if ScxrdReciprocalLatticeViewer is not available
          peakPanel.innerHTML = `
            <div class="text-center p-3">
              <i class="fas fa-table fa-3x mb-3 text-success"></i>
              <h6>Reciprocal Lattice</h6>
              <p class="text-muted small">Size: ${data.peak_table_size}</p>
              <a href="/wells/<%= @well.id %>/scxrd_datasets/${datasetId}/download_peak_table" 
                 class="btn btn-sm btn-success">
                <i class="fas fa-download me-1"></i>Download
              </a>
            </div>
          `;
        }
      } else {
        peakPanel.innerHTML = `
          <div class="text-center p-3 text-muted">
            <i class="fas fa-table fa-3x mb-3"></i>
            <h6>Reciprocal Lattice</h6>
            <p class="small">Not available</p>
          </div>
        `;
      }

      // Update structure panel (placeholder)
      const structurePanel = document.getElementById('scxrd-structure-panel');
      structurePanel.innerHTML = `
        <div class="text-center p-3">
          <i class="fas fa-cube fa-3x mb-3 text-info"></i>
          <h6>Crystal Structure</h6>
          <p class="text-muted small">3D visualization placeholder</p>
          <button class="btn btn-sm btn-info" disabled>
            <i class="fas fa-eye me-1"></i>View 3D
          </button>
        </div>
      `;

      // Update crystal image panel with well image and circle around closest point of interest
      const crystalImagePanel = document.getElementById('scxrd-crystal-image-panel');
      if (data.real_world_coordinates && data.real_world_coordinates.x_mm !== null && data.real_world_coordinates.y_mm !== null) {
        crystalImagePanel.innerHTML = `
          <div class="position-relative w-100 h-100">
            <div id="crystal-well-image-container" class="w-100 h-100 d-flex align-items-center justify-content-center">
              <div class="text-center">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
                <div class="mt-2 small">Loading well image...</div>
              </div>
            </div>
          </div>
        `;
        
        // Load well image with point of interest circle
        setTimeout(() => {
          window.loadWellImageWithCrystalLocation(datasetId, data.real_world_coordinates.x_mm, data.real_world_coordinates.y_mm, data.real_world_coordinates.z_mm);
        }, 100);
      } else {
        crystalImagePanel.innerHTML = `
          <div class="text-center p-3 text-muted">
            <i class="fas fa-gem fa-3x mb-3"></i>
            <h6>Crystal Image</h6>
            <p class="small">No crystal coordinates available</p>
          </div>
        `;
      }

      // Update experiment info card
      const infoCard = document.getElementById('scxrd-info-card');
      let unitCellInfo = '';
      if (data.unit_cell && data.unit_cell.a) {
        unitCellInfo = `| Cell: a=${data.unit_cell.a} b=${data.unit_cell.b} c=${data.unit_cell.c} =${data.unit_cell.alpha} =${data.unit_cell.beta} =${data.unit_cell.gamma}`;
      }
      
      infoCard.innerHTML = `
        <div class="card-body py-1">
          <div class="d-flex justify-content-between align-items-center">
            <div class="flex-grow-1 me-3">
              <span class="fw-bold">${experimentName}</span>
              <small class="text-muted ms-2">
                | Measured: ${data.date_measured || 'Unknown'}
                ${data.lattice_centring ? `| Lattice: ${data.lattice_centring}` : ''}
                ${data.real_world_coordinates ? `| Position: (${data.real_world_coordinates.x_mm || 'N/A'}, ${data.real_world_coordinates.y_mm || 'N/A'}, ${data.real_world_coordinates.z_mm || 'N/A'})mm` : ''}
                ${unitCellInfo}
              </small>
            </div>
            <div class="btn-group btn-group-sm flex-shrink-0">
            <a href="${datasetUrl}" class="btn btn-outline-primary">
              <i class="fas fa-eye me-1"></i>View Details
            </a>
            <a href="${datasetUrl}/edit" class="btn btn-outline-secondary">
              <i class="fas fa-edit me-1"></i>Edit
            </a>
            ${data.has_archive ? `
              <a href="/wells/<%= @well.id %>/scxrd_datasets/${datasetId}/download" class="btn btn-outline-success">
                <i class="fas fa-download me-1"></i>Archive
              </a>
            ` : ''}
            </div>
          </div>
        </div>
      `;
    })
    .catch(error => {
      console.error('Error loading SCXRD dataset details:', error);
    });
    
  // Update thumbnail highlighting
  document.querySelectorAll('.scxrd-thumbnail').forEach(thumb => {
    thumb.classList.remove('border-primary');
  });
  const selectedThumb = document.querySelector(`[data-dataset-id="${datasetId}"]`);
  if (selectedThumb) {
    selectedThumb.classList.add('border-primary');
  }
};
</script>

<div class="d-flex justify-content-between align-items-center mb-3">
  <h5 class="mb-0">SCXRD Datasets (<%= @well.scxrd_datasets.count %>)</h5>
  <a class="btn btn-primary btn-sm" href="<%= new_well_scxrd_dataset_path(@well) %>" target="_blank">
    Add SCXRD Dataset
  </a>
</div>

<% if @scxrd_datasets.any? %>
  <div class="row h-100">
    <!-- Main Display Area -->
    <div class="col-12 mb-3" style="height: 30vw;">
      <div class="row h-100 scxrd-main-row">
        <!-- First Diffraction Image Panel -->
        <div class="scxrd-card-container d-flex" data-card-id="diffraction">
          <div class="card h-100 w-100">
            <div class="card-header text-center bg-light">
              <small class="text-muted">Diffraction Image</small>
            </div>
            <div id="scxrd-first-image-panel" class="card-body p-0" style="position: relative;">
              <div class="d-flex align-items-center justify-content-center h-100 text-center text-muted">
                <div>
                  <i class="fas fa-camera fa-3x mb-3"></i>
                  <p>Select a dataset to view diffraction image</p>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Peak Table Panel -->
        <div class="scxrd-card-container d-flex" data-card-id="reciprocal">
          <div class="card h-100 w-100">
            <div class="card-header text-center bg-light">
              <small class="text-muted">Reciprocal Lattice</small>
            </div>
            <div id="scxrd-peak-table-panel" class="card-body p-0 d-flex align-items-center justify-content-center" style="height: 100%; overflow: hidden;">
              <div class="text-center text-muted">
                <i class="fas fa-table fa-3x mb-3"></i>
                <p>Select a dataset to view</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Crystal Image Panel -->
        <div class="scxrd-card-container d-flex" data-card-id="crystal-image">
          <div class="card h-100 w-100">
            <div class="card-header text-center bg-light">
              <small class="text-muted">Crystal Image</small>
            </div>
            <div id="scxrd-crystal-image-panel" class="card-body d-flex align-items-center justify-content-center">
              <div class="text-center text-muted">
                <i class="fas fa-gem fa-3x mb-3"></i>
                <p>Select a dataset to view crystal image</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Structure Panel -->
        <div class="scxrd-card-container d-flex minimized" data-card-id="structure">
          <div class="card h-100 w-100">
            <div class="card-header text-center bg-light">
              <small class="text-muted">Crystal Structure</small>
            </div>
            <div id="scxrd-structure-panel" class="card-body d-flex align-items-center justify-content-center">
              <div class="text-center text-muted">
                <i class="fas fa-cube fa-3x mb-3"></i>
                <p>Select a dataset to view</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Experiment Info Card -->
    <div class="col-12 mb-3">
      <div class="card">
        <div id="scxrd-info-card" class="text-center text-muted p-1">
          <i class="fas fa-info-circle me-2"></i>
          Select an SCXRD dataset to view experiment details
        </div>
      </div>
    </div>

    <!-- Dataset Navigator -->
    <div class="col-12">
      <div class="card">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span class="fw-bold">SCXRD Datasets (<%= @scxrd_datasets.count %>)</span>
          <a href="<%= new_well_scxrd_dataset_path(@well) %>" class="btn btn-sm btn-primary">
            <i class="fas fa-plus me-1"></i>Add Dataset
          </a>
        </div>
        <div class="card-body p-2">
          <div class="row g-2">
            <% @scxrd_datasets.each_with_index do |dataset, index| %>
              <div class="col-6 col-md-4 col-lg-3">
                <div class="card scxrd-thumbnail <%= 'border-primary' if index == 0 %>" 
                     data-dataset-id="<%= dataset.id %>"
                     style="cursor: pointer; transition: all 0.2s;"
                     onclick="showScxrdDatasetInMain('<%= dataset.id %>', '<%= j(dataset.experiment_name) %>', '<%= well_scxrd_dataset_path(@well, dataset) %>')">
                  <div class="card-body p-2 text-center">
                    <div class="mb-2">
                      <% if dataset.has_first_image? %>
                        <i class="fas fa-camera fa-2x text-primary"></i>
                      <% else %>
                        <i class="fas fa-camera fa-2x text-muted"></i>
                      <% end %>
                    </div>
                    <div class="small fw-bold text-truncate" title="<%= dataset.experiment_name %>">
                      <%= dataset.experiment_name %>
                    </div>
                    <div class="text-muted" style="font-size: 0.75rem;">
                      <%= dataset.date_measured&.strftime("%m/%d/%y") || "No date" %>
                    </div>
                    <div class="mt-1">
                      <% if dataset.has_peak_table? %>
                        <span class="badge bg-success" style="font-size: 0.6rem;">Peak Table</span>
                      <% end %>
                      <% if dataset.has_first_image? %>
                        <span class="badge bg-primary" style="font-size: 0.6rem;">Image</span>
                      <% end %>
                      <% if dataset.lattice_centring %>
                        <span class="badge bg-info" style="font-size: 0.6rem;"><%= dataset.lattice_centring.symbol %></span>
                      <% end %>
                    </div>
                  </div>
                </div>
              </div>
            <% end %>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Auto-select first dataset when the gallery loads
    <% if @scxrd_datasets.first %>
      // Wait for modules to load before initializing
      function initializeScxrdGallery() {
        console.log('Checking for ScxrdDiffractionViewer:', !!window.ScxrdDiffractionViewer);
        if (typeof window.showScxrdDatasetInMain === 'function') {
          showScxrdDatasetInMain(
            '<%= @scxrd_datasets.first.id %>', 
            '<%= j(@scxrd_datasets.first.experiment_name) %>', 
            '<%= well_scxrd_dataset_path(@well, @scxrd_datasets.first) %>'
          );
        } else {
          console.log('showScxrdDatasetInMain not available yet, retrying...');
          setTimeout(initializeScxrdGallery, 200);
        }
      }
      
      // Start initialization after DOM and modules are loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => setTimeout(initializeScxrdGallery, 500));
      } else {
        setTimeout(initializeScxrdGallery, 500);
      }
    <% end %>

// Function to load well image with crystal location circle
window.loadWellImageWithCrystalLocation = function(datasetId, crystalX, crystalY, crystalZ) {
  console.log(`Loading well image with crystal location: (${crystalX}, ${crystalY}, ${crystalZ})mm for dataset ${datasetId}`);
  
  const container = document.getElementById('crystal-well-image-container');
  if (!container) {
    console.error('Crystal well image container not found');
    return;
  }

  // For now, we'll use the spatial correlations endpoint but in a future improvement,
  // this should be split into separate endpoints for cleaner API architecture
  fetch(`/api/v1/wells/<%= @well.id %>/scxrd_datasets/spatial_correlations`, {
    headers: { 'Accept': 'application/json' }
  })
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.json();
    })
    .then(correlationData => {
      console.log('Spatial correlations data:', correlationData);
      
      // Find the closest POI to the current crystal coordinates
      let closestPOI = null;
      let minDistance = Infinity;
      let matchingDataset = null;
      
      if (correlationData && correlationData.correlations && Array.isArray(correlationData.correlations)) {
        correlationData.correlations.forEach(correlation => {
          const dataset = correlation.scxrd_dataset;
          const pois = correlation.point_of_interests;
          
          // Check if this dataset matches our crystal coordinates (within small tolerance)
          if (dataset && dataset.real_world_coordinates) {
            const datasetCoords = dataset.real_world_coordinates;
            const datasetDistance = Math.sqrt(
              Math.pow(datasetCoords.x_mm - crystalX, 2) + 
              Math.pow(datasetCoords.y_mm - crystalY, 2)
            );
            
            // If this dataset is close to our crystal location (within 0.1mm tolerance)
            if (datasetDistance < 0.1 && pois && Array.isArray(pois)) {
              pois.forEach(poi => {
                if (poi.distance_mm < minDistance) {
                  minDistance = poi.distance_mm;
                  closestPOI = poi;
                  matchingDataset = dataset;
                }
              });
            }
          }
        });
      }
      
      if (closestPOI && matchingDataset) {
        console.log(`Found spatial correlation: crystal at (${crystalX}, ${crystalY}) correlates with POI at pixel (${closestPOI.pixel_coordinates.x}, ${closestPOI.pixel_coordinates.y}) at distance ${minDistance.toFixed(3)}mm`);
        console.log(`Loading image with ID: ${closestPOI.image_id}`);
        
        // Fetch the image details to get the file URL
        fetch(`/api/v1/wells/<%= @well.id %>/images/${closestPOI.image_id}`, {
          headers: { 'Accept': 'application/json' }
        })
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
          })
          .then(imageData => {
            console.log('Image data:', imageData);
            const imageUrl = imageData.data ? imageData.data.file_url : null;
            const pixelSizeX = imageData.data ? imageData.data.pixel_size_x_mm : null;
            const pixelSizeY = imageData.data ? imageData.data.pixel_size_y_mm : null;
            
            if (imageUrl && pixelSizeX && pixelSizeY) {
              // Load the specific image where the POI is defined with the circle overlay
              container.innerHTML = `
                <div class="position-relative w-100 h-100">
                  <img id="well-image-with-crystal" 
                       src="${imageUrl}" 
                       class="img-fluid w-100 h-100"
                       style="object-fit: contain;"
                       data-pixel-size-x="${pixelSizeX}"
                       data-pixel-size-y="${pixelSizeY}"
                       onload="window.drawCrystalLocationCircle(${closestPOI.pixel_coordinates.x}, ${closestPOI.pixel_coordinates.y})"
                       onerror="window.handleWellImageError()">
                  <canvas id="crystal-location-overlay" 
                          class="position-absolute top-0 start-0" 
                          style="pointer-events: none; z-index: 10;">
                  </canvas>
                </div>
              `;
            } else {
              throw new Error('Image URL or pixel size information not available');
            }
          })
          .catch(error => {
            console.error('Error loading image:', error);
            container.innerHTML = `
              <div class="text-center p-3 text-muted">
                <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
                <h6>Image Load Error</h6>
                <p class="small">Could not load image: ${error.message}</p>
              </div>
            `;
          });
      } else {
        console.log('No spatial correlations found for this crystal location');
        container.innerHTML = `
          <div class="text-center p-3 text-muted">
            <i class="fas fa-gem fa-3x mb-3"></i>
            <h6>Crystal Image</h6>
            <p class="small">No spatial correlations found for this crystal location</p>
          </div>
        `;
      }
    })
    .catch(error => {
      console.error('Error loading spatial correlations:', error);
      container.innerHTML = `
        <div class="text-center p-3 text-muted">
          <i class="fas fa-exclamation-triangle fa-3x mb-3"></i>
          <h6>Error</h6>
          <p class="small">Failed to load crystal location correlations</p>
        </div>
      `;
    });
}

// Function to draw circle around crystal location
window.drawCrystalLocationCircle = function(pixelX, pixelY) {
  const img = document.getElementById('well-image-with-crystal');
  const canvas = document.getElementById('crystal-location-overlay');
  
  if (!img || !canvas) {
    console.error('Image or canvas not found for drawing crystal circle');
    return;
  }

  // Set canvas size to match image display size
  const imgRect = img.getBoundingClientRect();
  canvas.width = imgRect.width;
  canvas.height = imgRect.height;

  const ctx = canvas.getContext('2d');
  
  // Calculate scaling factors
  const scaleX = imgRect.width / img.naturalWidth;
  const scaleY = imgRect.height / img.naturalHeight;
  
  // Scale pixel coordinates to canvas coordinates
  const canvasX = pixelX * scaleX;
  const canvasY = pixelY * scaleY;
  
  // Get actual pixel size from image data attributes
  const pixelSizeX = parseFloat(img.getAttribute('data-pixel-size-x')) || 0.01; // fallback to 0.01mm/pixel
  const pixelSizeY = parseFloat(img.getAttribute('data-pixel-size-y')) || 0.01; // fallback to 0.01mm/pixel
  
  // Calculate circle radius for 0.3mm using actual pixel size
  const radiusInPixelsX = 0.3 / pixelSizeX; // 0.3mm converted to pixels using X scale
  const radiusInPixelsY = 0.3 / pixelSizeY; // 0.3mm converted to pixels using Y scale
  
  // Use average radius and scale to display size
  const averageRadiusPixels = (radiusInPixelsX + radiusInPixelsY) / 2;
  const circleRadius = averageRadiusPixels * scaleX;
  
  // Draw circle
  ctx.strokeStyle = '#ff0000'; // Red circle
  ctx.lineWidth = 3;
  ctx.setLineDash([5, 5]); // Dashed line
  ctx.beginPath();
  ctx.arc(canvasX, canvasY, circleRadius, 0, 2 * Math.PI);
  ctx.stroke();
  
  // Draw center dot
  ctx.fillStyle = '#ff0000';
  ctx.setLineDash([]); // Solid line for dot
  ctx.beginPath();
  ctx.arc(canvasX, canvasY, 2, 0, 2 * Math.PI);
  ctx.fill();
  
  console.log(`Drew crystal location circle at (${canvasX.toFixed(1)}, ${canvasY.toFixed(1)}) with radius ${circleRadius.toFixed(1)}px`);
  console.log(`Using pixel scale: ${pixelSizeX}mm/px (X), ${pixelSizeY}mm/px (Y), 0.3mm = ${averageRadiusPixels.toFixed(1)} pixels`);
}

// Function to handle well image loading errors
window.handleWellImageError = function() {
  const container = document.getElementById('crystal-well-image-container');
  if (container) {
    container.innerHTML = `
      <div class="text-center p-3 text-muted">
        <i class="fas fa-image fa-3x mb-3"></i>
        <h6>Well Image</h6>
        <p class="small">Image not available</p>
      </div>
    `;
  }
}

  </script>

<% else %>
  <div class="alert alert-info text-center">
    <h6>No SCXRD Datasets</h6>
    <p>No single crystal X-ray diffraction datasets have been uploaded for this well yet.</p>
    <a href="<%= new_well_scxrd_dataset_path(@well) %>" class="btn btn-primary">Add First SCXRD Dataset</a>
  </div>
<% end %>